<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caching With Rails - </title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <h1 class="logo">
                    <a href="/">Rails Kılavuzları</a>
                </h1>
                <nav class="nav">
                    <a href="/">Ana Sayfa</a>
                    <a href="https://dilankaya127.github.io">Portföy</a>
                    <a href="https://github.com/dilankaya127/rails-tr-TR">GitHub</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="guide-container">
    <aside class="guide-sidebar">
        <div class="guide-toc">
            <h3>İçindekiler</h3>
            <div id="toc"></div>
        </div>
        
        <div class="guide-nav">
            <h3>Diğer Kılavuzlar</h3>
            <ul>
                <li><a href="/rails-tr-TR/guides/tr/getting_started">Rails ile Başlarken</a></li>
                <li><a href="/rails-tr-TR/guides/en/active_record_basics">Active Record Temelleri</a></li>
                <li><a href="/rails-tr-TR/guides//en/action_controller_overview">Action Controller</a></li>
                <li><a href="/rails-tr-TR/guides/tr/action_cable_overview">Action Cable</a></li>
            </ul>
        </div>
    </aside>

    <article class="guide-content">
        <header class="guide-header">
            <h1>Caching With Rails</h1>
            
        </header>

        <div class="guide-body">
            <p><strong>DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p>

<h1 id="caching-with-rails-an-overview">Caching with Rails: An Overview</h1>

<p>This guide is an introduction to speeding up your Rails application with caching.</p>

<p>After reading this guide, you will know:</p>

<ul>
  <li>What caching is.</li>
  <li>The types of caching strategies.</li>
  <li>How to manage the caching dependencies.</li>
  <li>Solid Cache - a database-backed Active Support cache store.</li>
  <li>Other cache stores.</li>
  <li>Cache keys.</li>
  <li>Conditional GET support.</li>
</ul>

<hr />

<h2 id="what-is-caching">What is Caching?</h2>

<p>Caching means storing content generated during the request-response cycle and
reusing it when responding to similar requests. It’s like keeping your favorite
coffee mug right on your desk instead of in the kitchen cabinet — it’s ready
when you need it, saving you time and effort.</p>

<p>Caching is one of the most effective ways to boost an application’s performance.
It allows websites running on modest infrastructure — a single server with a
single database — to sustain thousands of concurrent users.</p>

<p>Rails provides a set of caching features out of the box which allows you to not
only cache data, but also to tackle challenges like cache expiration, cache
dependencies, and cache invalidation.</p>

<p>This guide will explore Rails’ comprehensive caching strategies, from fragment
caching to SQL caching. With these techniques, your Rails application can serve
millions of views while keeping response times low and server bills manageable.</p>

<h2 id="types-of-caching">Types of Caching</h2>

<p>This is an introduction to some of the common types of caching.</p>

<p>By default, Action Controller caching is only enabled in your production environment. You can play
around with caching locally by running <code class="language-plaintext highlighter-rouge">bin/rails dev:cache</code>, or by setting
<a href="configuring.html#config-action-controller-perform-caching"><code class="language-plaintext highlighter-rouge">config.action_controller.perform_caching</code></a> to <code class="language-plaintext highlighter-rouge">true</code> in <code class="language-plaintext highlighter-rouge">config/environments/development.rb</code>.</p>

<p>NOTE: Changing the value of <code class="language-plaintext highlighter-rouge">config.action_controller.perform_caching</code> will
only have an effect on the caching provided by Action Controller.
For instance, it will not impact low-level caching, that we address
<a href="#low-level-caching-using-rails-cache">below</a>.</p>

<h3 id="fragment-caching">Fragment Caching</h3>

<p>Dynamic web applications usually build pages with a variety of components not
all of which have the same caching characteristics. When different parts of the
page need to be cached and expired separately you can use Fragment Caching.</p>

<p>Fragment Caching allows a fragment of view logic to be wrapped in a cache block and served out of the cache store when the next request comes in.</p>

<p>For example, if you wanted to cache each product on a page, you could use this
code:</p>

<pre><code class="language-html+erb">&lt;% @products.each do |product| %&gt;
  &lt;% cache product do %&gt;
    &lt;%= render product %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</code></pre>

<p>When your application receives its first request to this page, Rails will write
a new cache entry with a unique key. A key looks something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>views/products/index:bea67108094918eeba42cd4a6e786901/products/1
</code></pre></div></div>

<p>The string of characters in the middle is a template tree digest. It is a hash
digest computed based on the contents of the view fragment you are caching. If
you change the view fragment (e.g., the HTML changes), the digest will change,
expiring the existing file.</p>

<p>A cache version, derived from the product record, is stored in the cache entry.
When the product is touched, the cache version changes, and any cached fragments
that contain the previous version are ignored.</p>

<p>TIP: Cache stores like Memcached will automatically delete old cache files.</p>

<p>If you want to cache a fragment under certain conditions, you can use
<code class="language-plaintext highlighter-rouge">cache_if</code> or <code class="language-plaintext highlighter-rouge">cache_unless</code>:</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%</span> <span class="n">cache_if</span> <span class="n">admin?</span><span class="p">,</span> <span class="n">product</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="n">product</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<h4 id="collection-caching">Collection Caching</h4>

<p>The <code class="language-plaintext highlighter-rouge">render</code> helper can also cache individual templates rendered for a collection.
It can even one up the previous example with <code class="language-plaintext highlighter-rouge">each</code> by reading all cache
templates at once instead of one by one. This is done by passing <code class="language-plaintext highlighter-rouge">cached: true</code> when rendering the collection:</p>

<pre><code class="language-html+erb">&lt;%= render partial: 'products/product', collection: @products, cached: true %&gt;
</code></pre>

<p>All cached templates from previous renders will be fetched at once with much
greater speed. Additionally, the templates that haven’t yet been cached will be
written to cache and multi fetched on the next render.</p>

<p>The cache key can be configured. In the example below, it is prefixed with the
current locale to ensure that different localizations of the product page
do not overwrite each other:</p>

<pre><code class="language-html+erb">&lt;%= render partial: 'products/product',
           collection: @products,
           cached: -&gt;(product) { [I18n.locale, product] } %&gt;
</code></pre>

<h3 id="russian-doll-caching">Russian Doll Caching</h3>

<p>You may want to nest cached fragments inside other cached fragments. This is
called Russian doll caching.</p>

<p>The advantage of Russian doll caching is that if a single product is updated,
all the other inner fragments can be reused when regenerating the outer
fragment.</p>

<p>As explained in the previous section, a cached file will expire if the value of
<code class="language-plaintext highlighter-rouge">updated_at</code> changes for a record on which the cached file directly depends.
However, this will not expire any cache the fragment is nested within.</p>

<p>For example, take the following view:</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%</span> <span class="n">cache</span> <span class="n">product</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="n">product</span><span class="p">.</span><span class="nf">games</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>Which in turn renders this view:</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%</span> <span class="n">cache</span> <span class="n">game</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="n">game</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>If any attribute of game is changed, the <code class="language-plaintext highlighter-rouge">updated_at</code> value will be set to the
current time, thereby expiring the cache. However, because <code class="language-plaintext highlighter-rouge">updated_at</code>
will not be changed for the product object, that cache will not be expired and
your app will serve stale data. To fix this, we tie the models together with
the <code class="language-plaintext highlighter-rouge">touch</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:games</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Game</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:product</span><span class="p">,</span> <span class="ss">touch: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">touch</code> set to <code class="language-plaintext highlighter-rouge">true</code>, any action which changes <code class="language-plaintext highlighter-rouge">updated_at</code> for a game
record will also change it for the associated product, thereby expiring the
cache.</p>

<h3 id="shared-partial-caching">Shared Partial Caching</h3>

<p>It is possible to share partials and associated caching between files with different MIME types. For example shared partial caching allows template writers to share a partial between HTML and JavaScript files. When templates are collected in the template resolver file paths they only include the template language extension and not the MIME type. Because of this templates can be used for multiple MIME types. Both HTML and JavaScript requests will respond to the following code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">render</span><span class="p">(</span><span class="ss">partial: </span><span class="s2">"hotels/hotel"</span><span class="p">,</span> <span class="ss">collection: </span><span class="vi">@hotels</span><span class="p">,</span> <span class="ss">cached: </span><span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>Will load a file named <code class="language-plaintext highlighter-rouge">hotels/hotel.erb</code>.</p>

<p>Another option is to include the <code class="language-plaintext highlighter-rouge">formats</code> attribute to the partial to render.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">render</span><span class="p">(</span><span class="ss">partial: </span><span class="s2">"hotels/hotel"</span><span class="p">,</span> <span class="ss">collection: </span><span class="vi">@hotels</span><span class="p">,</span> <span class="ss">formats: :html</span><span class="p">,</span> <span class="ss">cached: </span><span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>Will load a file named <code class="language-plaintext highlighter-rouge">hotels/hotel.html.erb</code> in any file MIME type, for example you could include this partial in a JavaScript file.</p>

<h3 id="low-level-caching-using-railscache">Low-Level Caching using <code class="language-plaintext highlighter-rouge">Rails.cache</code></h3>

<p>Sometimes you need to cache a particular value or query result instead of caching view fragments. Rails’ caching mechanism works great for storing any serializable information.</p>

<p>An efficient way to implement low-level caching is using the <code class="language-plaintext highlighter-rouge">Rails.cache.fetch</code> method. This method handles both <em>reading from</em> and <em>writing to</em> the cache. When called with a single argument, it fetches and returns the cached value for the given key. If a block is passed, the block is executed only on a cache miss. The block’s return value is written to the cache under the given cache key and returned. In case of cache hit, the cached value is returned directly without executing the block.</p>

<p>Consider the following example. An application has a <code class="language-plaintext highlighter-rouge">Product</code> model with an instance method that looks up the product’s price on a competing website. The data returned by this method would be perfect for low-level caching:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nf">competing_price</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">cache_key_with_version</span><span class="si">}</span><span class="s2">/competing_price"</span><span class="p">,</span> <span class="ss">expires_in: </span><span class="mi">12</span><span class="p">.</span><span class="nf">hours</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">Competitor</span><span class="o">::</span><span class="no">API</span><span class="p">.</span><span class="nf">find_price</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>NOTE: Notice that in this example we used the <code class="language-plaintext highlighter-rouge">cache_key_with_version</code> method, so the resulting cache key will be something like <code class="language-plaintext highlighter-rouge">products/233-20140225082222765838000/competing_price</code>. <code class="language-plaintext highlighter-rouge">cache_key_with_version</code> generates a string based on the model’s class name, <code class="language-plaintext highlighter-rouge">id</code>, and <code class="language-plaintext highlighter-rouge">updated_at</code> attributes. This is a common convention and has the benefit of invalidating the cache whenever the product is updated. In general, when you use low-level caching, you need to generate a cache key.</p>

<p>Below are some more examples of how to use low-level caching:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Store a value in the cache</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"greeting"</span><span class="p">,</span> <span class="s2">"Hello, world!"</span><span class="p">)</span>

<span class="c1"># Retrieve the value from the cache</span>
<span class="n">greeting</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"greeting"</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">greeting</span> <span class="c1"># Output: Hello, world!</span>

<span class="c1"># Fetch a value with a block to set a default if it doesn’t exist</span>
<span class="n">welcome_message</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"welcome_message"</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"Welcome to Rails!"</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="n">welcome_message</span> <span class="c1"># Output: Welcome to Rails!</span>

<span class="c1"># Delete a value from the cache</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s2">"greeting"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="avoid-caching-instances-of-active-record-objects">Avoid Caching Instances of Active Record Objects</h4>

<p>Consider this example, which stores a list of Active Record objects representing superusers in the cache:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># super_admins is an expensive SQL query, so don't run it too often</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"super_admin_users"</span><span class="p">,</span> <span class="ss">expires_in: </span><span class="mi">12</span><span class="p">.</span><span class="nf">hours</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">User</span><span class="p">.</span><span class="nf">super_admins</span><span class="p">.</span><span class="nf">to_a</span>
<span class="k">end</span>
</code></pre></div></div>

<p>You should <strong>avoid</strong> this pattern. Why? Because the instance could change. In production, attributes
on it could differ, or the record could be deleted. And in development, it works unreliably with
cache stores that reload code when you make changes.</p>

<p>Instead, cache the ID or some other primitive data type. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># super_admins is an expensive SQL query, so don't run it too often</span>
<span class="n">ids</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"super_admin_user_ids"</span><span class="p">,</span> <span class="ss">expires_in: </span><span class="mi">12</span><span class="p">.</span><span class="nf">hours</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">User</span><span class="p">.</span><span class="nf">super_admins</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="k">end</span>
<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">ids</span><span class="p">).</span><span class="nf">to_a</span>
</code></pre></div></div>

<h3 id="sql-caching">SQL Caching</h3>

<p>Query caching is a Rails feature that caches the result set returned by each
query. If Rails encounters the same query again for that request, it will use
the cached result set as opposed to running the query against the database
again.</p>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="c1"># Run a find query</span>
    <span class="vi">@products</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">all</span>

    <span class="c1"># ...</span>

    <span class="c1"># Run the same query again</span>
    <span class="vi">@products</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">all</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The second time the same query is run against the database, it’s not actually going to hit the database. The first time the result is returned from the query it is stored in the query cache (in memory) and the second time it’s pulled from memory. However, each retrieval still instantiates new instances of the queried objects.</p>

<p>NOTE: Query caches are created at the start of an action and destroyed at the
end of that action and thus persist only for the duration of the action. If
you’d like to store query results in a more persistent fashion, you can with
low-level caching.</p>

<h2 id="managing-dependencies">Managing Dependencies</h2>

<p>In order to correctly invalidate the cache, you need to properly define the
caching dependencies. Rails is clever enough to handle common cases so you don’t
have to specify anything. However, sometimes, when you’re dealing with custom
helpers for instance, you need to explicitly define them.</p>

<h3 id="implicit-dependencies">Implicit Dependencies</h3>

<p>Most template dependencies can be derived from calls to <code class="language-plaintext highlighter-rouge">render</code> in the template
itself. Here are some examples of render calls that <a href="https://api.rubyonrails.org/classes/ActionView/Digestor.html"><code class="language-plaintext highlighter-rouge">ActionView::Digestor</code></a> knows
how to decode:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">render</span> <span class="ss">partial: </span><span class="s2">"comments/comment"</span><span class="p">,</span> <span class="ss">collection: </span><span class="n">commentable</span><span class="p">.</span><span class="nf">comments</span>
<span class="n">render</span> <span class="s2">"comments/comments"</span>
<span class="n">render</span><span class="p">(</span><span class="s2">"comments/comments"</span><span class="p">)</span>

<span class="n">render</span> <span class="s2">"header"</span> <span class="c1"># translates to render("comments/header")</span>

<span class="n">render</span><span class="p">(</span><span class="vi">@topic</span><span class="p">)</span>         <span class="c1"># translates to render("topics/topic")</span>
<span class="n">render</span><span class="p">(</span><span class="n">topics</span><span class="p">)</span>         <span class="c1"># translates to render("topics/topic")</span>
<span class="n">render</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="nf">topics</span><span class="p">)</span> <span class="c1"># translates to render("topics/topic")</span>
</code></pre></div></div>

<p>On the other hand, some calls need to be changed to make caching work properly.
For instance, if you’re passing a custom collection, you’ll need to change:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">render</span> <span class="vi">@project</span><span class="p">.</span><span class="nf">documents</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>to:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">render</span> <span class="ss">partial: </span><span class="s2">"documents/document"</span><span class="p">,</span> <span class="ss">collection: </span><span class="vi">@project</span><span class="p">.</span><span class="nf">documents</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="explicit-dependencies">Explicit Dependencies</h3>

<p>Sometimes you’ll have template dependencies that can’t be derived at all. This
is typically the case when rendering happens in helpers. Here’s an example:</p>

<pre><code class="language-html+erb">&lt;%= render_sortable_todolists @project.todolists %&gt;
</code></pre>

<p>You’ll need to use a special comment format to call those out:</p>

<pre><code class="language-html+erb">&lt;%# Template Dependency: todolists/todolist %&gt;
&lt;%= render_sortable_todolists @project.todolists %&gt;
</code></pre>

<p>In some cases, like a single table inheritance setup, you might have a bunch of
explicit dependencies. Instead of writing every template out, you can use a
wildcard to match any template in a directory:</p>

<pre><code class="language-html+erb">&lt;%# Template Dependency: events/* %&gt;
&lt;%= render_categorizable_events @person.events %&gt;
</code></pre>

<p>As for collection caching, if the partial template doesn’t start with a clean
cache call, you can still benefit from collection caching by adding a special
comment format anywhere in the template, like:</p>

<pre><code class="language-html+erb">&lt;%# Template Collection: notification %&gt;
&lt;% my_helper_that_calls_cache(some_arg, notification) do %&gt;
  &lt;%= notification.name %&gt;
&lt;% end %&gt;
</code></pre>

<h3 id="external-dependencies">External Dependencies</h3>

<p>If you use a helper method, for example, inside a cached block and you then update
that helper, you’ll have to bump the cache as well. It doesn’t really matter how
you do it, but the MD5 of the template file must change. One recommendation is to
simply be explicit in a comment, like:</p>

<pre><code class="language-html+erb">&lt;%# Helper Dependency Updated: Jul 28, 2015 at 7pm %&gt;
&lt;%= some_helper_method(person) %&gt;
</code></pre>

<h2 id="solid-cache">Solid Cache</h2>

<p>Solid Cache is a database-backed Active Support cache store. It leverages the
speed of modern <a href="https://en.wikipedia.org/wiki/Solid-state_drive">SSDs</a> (Solid
State Drives) to offer cost-effective caching with larger storage capacity and
simplified infrastructure. While SSDs are slightly slower than RAM, the
difference is minimal for most applications. SSDs compensate for this by not
needing to be invalidated as frequently, since they can store much more data. As
a result, there are fewer cache misses on average, leading to fast response
times.</p>

<p>Solid Cache uses a FIFO (First In, First Out) caching strategy, where the first
item added to the cache is the first one to be removed when the cache reaches
its limit. This approach is simpler but less efficient compared to an LRU (Least
Recently Used) cache, which removes the least recently accessed items first,
better optimizing for frequently used data. However, Solid Cache compensates for
the lower efficiency of FIFO by allowing the cache to live longer, reducing the
frequency of invalidations.</p>

<p>Solid Cache is enabled by default from Rails version 8.0 and onward. However, if
you’d prefer not to utilize it, you can skip Solid Cache:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rails new app_name <span class="nt">--skip-solid</span>
</code></pre></div></div>

<p>WARNING: All parts of the Solid Trifecta (Solid Cache, Solid Queue and Solid
Cable) are bundled behind the <code class="language-plaintext highlighter-rouge">--skip-solid</code> flag. If you still want to use
Solid Queue and Solid Cable but not Solid Cache, you can install them
separately by following <a href="https://github.com/rails/solid_queue#installation">Solid Queue
Installation</a> and
<a href="https://github.com/rails/solid_cable#installation">Solid Cable Installation</a>
respectively.</p>

<h3 id="configuring-the-database">Configuring the Database</h3>

<p>To use Solid Cache, you can configure the database connection in your
<code class="language-plaintext highlighter-rouge">config/database.yml</code> file. Here’s an example configuration for a SQLite
database:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">production</span><span class="pi">:</span>
  <span class="na">primary</span><span class="pi">:</span>
    <span class="na">&lt;&lt;</span><span class="pi">:</span> <span class="nv">*default</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">storage/production.sqlite3</span>
  <span class="na">cache</span><span class="pi">:</span>
    <span class="na">&lt;&lt;</span><span class="pi">:</span> <span class="nv">*default</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">storage/production_cache.sqlite3</span>
    <span class="na">migrations_paths</span><span class="pi">:</span> <span class="s">db/cache_migrate</span>
</code></pre></div></div>

<p>In this configuration, the <code class="language-plaintext highlighter-rouge">cache</code> database is used to store cached data. You
can also specify a different database adapter, like MySQL or PostgreSQL, if you
prefer.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">production</span><span class="pi">:</span>
  <span class="na">primary</span><span class="pi">:</span> <span class="nl">&amp;primary_production</span>
    <span class="na">&lt;&lt;</span><span class="pi">:</span> <span class="nv">*default</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">app_production</span>
    <span class="na">username</span><span class="pi">:</span> <span class="s">app</span>
    <span class="na">password</span><span class="pi">:</span> <span class="s">&lt;%= ENV["APP_DATABASE_PASSWORD"] %&gt;</span>
  <span class="na">cache</span><span class="pi">:</span>
    <span class="na">&lt;&lt;</span><span class="pi">:</span> <span class="nv">*primary_production</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">app_production_cache</span>
    <span class="na">migrations_paths</span><span class="pi">:</span> <span class="s">db/cache_migrate</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">database</code> or <a href="#sharding-the-cache"><code class="language-plaintext highlighter-rouge">databases</code></a> is not specified in the
cache configuration, Solid Cache will use the ActiveRecord::Base connection
pool. This means that cache reads and writes will be part of any wrapping
database transaction.</p>

<p>In production, the cache store is configured to use the Solid Cache store by
default:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># config/environments/production.rb</span>
  <span class="s">config.cache_store = :solid_cache_store</span>
</code></pre></div></div>

<p>You can <a href="#low-level-caching-using-rails-cache">access the cache by calling
<code class="language-plaintext highlighter-rouge">Rails.cache</code></a></p>

<h3 id="customizing-the-cache-store">Customizing the Cache Store</h3>

<p>Solid Cache can be customized through the config/cache.yml file:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">default</span><span class="pi">:</span> <span class="nl">&amp;default</span>
  <span class="na">store_options</span><span class="pi">:</span>
    <span class="c1"># Cap age of oldest cache entry to fulfill retention policies</span>
    <span class="na">max_age</span><span class="pi">:</span> <span class="s">&lt;%= 60.days.to_i %&gt;</span>
    <span class="na">max_size</span><span class="pi">:</span> <span class="s">&lt;%= 256.megabytes %&gt;</span>
    <span class="na">namespace</span><span class="pi">:</span> <span class="s">&lt;%= Rails.env %&gt;</span>
</code></pre></div></div>

<p>For the full list of keys for store_options see <a href="https://github.com/rails/solid_cache#cache-configuration">Cache
configuration</a>.</p>

<p>Here, you can adjust the <code class="language-plaintext highlighter-rouge">max_age</code> and <code class="language-plaintext highlighter-rouge">max_size</code> options to control the age and
size of the cache entries.</p>

<h3 id="handling-cache-expiration">Handling Cache Expiration</h3>

<p>Solid Cache tracks cache writes by incrementing a counter with each write. When
the counter reaches 50% of the <code class="language-plaintext highlighter-rouge">expiry_batch_size</code> from the <a href="https://github.com/rails/solid_cache#cache-configuration">Cache
configuration</a>, a
background task is triggered to handle cache expiry. This approach ensures cache
records expire faster than they are written when the cache needs to shrink.</p>

<p>The background task only runs when there are writes, so the process stays idle
when the cache is not being updated. If you prefer to run the expiry process in
a background job instead of a thread, set <code class="language-plaintext highlighter-rouge">expiry_method</code> from the<a href="https://github.com/rails/solid_cache#cache-configuration">Cache
configuration</a> to
<code class="language-plaintext highlighter-rouge">:job</code>.</p>

<h3 id="sharding-the-cache">Sharding the Cache</h3>

<p>If you need more scalability, Solid Cache supports sharding — splitting the
cache across multiple databases. This spreads the load, making your cache even
more powerful. To enable sharding, add multiple cache databases to your
database.yml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/database.yml</span>
<span class="na">production</span><span class="pi">:</span>
  <span class="na">cache_shard1</span><span class="pi">:</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">cache1_production</span>
    <span class="na">host</span><span class="pi">:</span> <span class="s">cache1-db</span>
  <span class="na">cache_shard2</span><span class="pi">:</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">cache2_production</span>
    <span class="na">host</span><span class="pi">:</span> <span class="s">cache2-db</span>
  <span class="na">cache_shard3</span><span class="pi">:</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">cache3_production</span>
    <span class="na">host</span><span class="pi">:</span> <span class="s">cache3-db</span>
</code></pre></div></div>

<p>Additionally, you must specify the shards in the cache configuration:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/cache.yml</span>
<span class="na">production</span><span class="pi">:</span>
  <span class="na">databases</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">cache_shard1</span><span class="pi">,</span> <span class="nv">cache_shard2</span><span class="pi">,</span> <span class="nv">cache_shard3</span><span class="pi">]</span>
</code></pre></div></div>

<h3 id="encryption">Encryption</h3>

<p>Solid Cache supports encryption to protect sensitive data. To enable encryption,
set the <code class="language-plaintext highlighter-rouge">encrypt</code> value in your cache configuration:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/cache.yml</span>
<span class="na">production</span><span class="pi">:</span>
  <span class="na">encrypt</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div>

<p>You will need to set up your application to use<a href="active_record_encryption.html">Active Record
Encryption</a>.</p>

<h3 id="caching-in-development">Caching in Development</h3>

<p>By default, caching is <em>enabled</em> in development mode with
<a href="#activesupport-cache-memorystore"><code class="language-plaintext highlighter-rouge">:memory_store</code></a>. This doesn’t apply to
Action Controller caching, which is disabled by default.</p>

<p>To enable Action Controller caching Rails provides the <code class="language-plaintext highlighter-rouge">bin/rails dev:cache</code>
command.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bin/rails dev:cache
Development mode is now being cached.
<span class="nv">$ </span>bin/rails dev:cache
Development mode is no longer being cached.
</code></pre></div></div>

<p>If you want to use Solid Cache in development, set the <code class="language-plaintext highlighter-rouge">cache_store</code>
configuration in <code class="language-plaintext highlighter-rouge">config/environments/development.rb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:solid_cache_store</span>
</code></pre></div></div>

<p>and ensure the <code class="language-plaintext highlighter-rouge">cache</code> database is created and migrated:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>development:
  &lt;&lt;: <span class="k">*</span> default
  database: cache
</code></pre></div></div>

<p>TIP: To disable caching set <code class="language-plaintext highlighter-rouge">cache_store</code> to
<a href="#activesupport-cache-nullstore"><code class="language-plaintext highlighter-rouge">:null_store</code></a></p>

<h2 id="other-cache-stores">Other Cache Stores</h2>

<p>Rails provides different stores for the cached data (with the exception of SQL
Caching).</p>

<h3 id="configuration">Configuration</h3>

<p>You can set up a different cache store by setting the
<code class="language-plaintext highlighter-rouge">config.cache_store</code> configuration option. Other parameters can be passed as
arguments to the cache store’s constructor:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:memory_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">size: </span><span class="mi">64</span><span class="p">.</span><span class="nf">megabytes</span> <span class="p">}</span>
</code></pre></div></div>

<p>Alternatively, you can set <code class="language-plaintext highlighter-rouge">ActionController::Base.cache_store</code> outside of a configuration block.</p>

<p>You can access the cache by calling <code class="language-plaintext highlighter-rouge">Rails.cache</code>.</p>

<h4 id="connection-pool-options">Connection Pool Options</h4>

<p><a href="#activesupport-cache-memcachestore"><code class="language-plaintext highlighter-rouge">:mem_cache_store</code></a> and
<a href="#activesupport-cache-rediscachestore"><code class="language-plaintext highlighter-rouge">:redis_cache_store</code></a> are configured to
use connection pooling. This means that if you’re using Puma, or another
threaded server, you can have multiple threads performing queries to the cache
store at the same time.</p>

<p>If you want to disable connection pooling, set <code class="language-plaintext highlighter-rouge">:pool</code> option to <code class="language-plaintext highlighter-rouge">false</code> when configuring the cache store:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:mem_cache_store</span><span class="p">,</span> <span class="s2">"cache.example.com"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">pool: </span><span class="kp">false</span> <span class="p">}</span>
</code></pre></div></div>

<p>You can also override default pool settings by providing individual options to the <code class="language-plaintext highlighter-rouge">:pool</code> option:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:mem_cache_store</span><span class="p">,</span> <span class="s2">"cache.example.com"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">pool: </span><span class="p">{</span> <span class="ss">size: </span><span class="mi">32</span><span class="p">,</span> <span class="ss">timeout: </span><span class="mi">1</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:size</code> - This option sets the number of connections per process (defaults to 5).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:timeout</code> - This option sets the number of seconds to wait for a connection (defaults to 5). If no connection is available within the timeout, a <code class="language-plaintext highlighter-rouge">Timeout::Error</code> will be raised.</p>
  </li>
</ul>

<h3 id="activesupportcachestore"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::Store</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::Store</code></a> provides the foundation for interacting with the cache in Rails. This is an abstract class, and you cannot use it on its own. Instead, you must use a concrete implementation of the class tied to a storage engine. Rails ships with several implementations, documented below.</p>

<p>The main API methods are <a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-read"><code class="language-plaintext highlighter-rouge">read</code></a>, <a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-write"><code class="language-plaintext highlighter-rouge">write</code></a>, <a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-delete"><code class="language-plaintext highlighter-rouge">delete</code></a>, <a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-exist-3F"><code class="language-plaintext highlighter-rouge">exist?</code></a>, and <a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch"><code class="language-plaintext highlighter-rouge">fetch</code></a>.</p>

<p>Options passed to the cache store’s constructor will be treated as default options for the appropriate API methods.</p>

<h3 id="activesupportcachememorystore"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::MemoryStore</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/MemoryStore.html"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::MemoryStore</code></a> keeps entries in memory in the same Ruby process. The cache
store has a bounded size specified by sending the <code class="language-plaintext highlighter-rouge">:size</code> option to the
initializer (default is 32Mb). When the cache exceeds the allotted size, a
cleanup will occur and the least recently used entries will be removed.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:memory_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">size: </span><span class="mi">64</span><span class="p">.</span><span class="nf">megabytes</span> <span class="p">}</span>
</code></pre></div></div>

<p>If you’re running multiple Ruby on Rails server processes (which is the case
if you’re using Phusion Passenger or puma clustered mode), then your Rails server
process instances won’t be able to share cache data with each other. This cache
store is not appropriate for large application deployments. However, it can
work well for small, low traffic sites with only a couple of server processes,
as well as development and test environments.</p>

<p>New Rails projects are configured to use this implementation in the development environment by default.</p>

<p>NOTE: Since processes will not share cache data when using <code class="language-plaintext highlighter-rouge">:memory_store</code>,
it will not be possible to manually read, write, or expire the cache via the Rails console.</p>

<h3 id="activesupportcachefilestore"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::FileStore</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/FileStore.html"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::FileStore</code></a> uses the file system to store entries. The path to the directory where the store files will be stored must be specified when initializing the cache.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:file_store</span><span class="p">,</span> <span class="s2">"/path/to/cache/directory"</span>
</code></pre></div></div>

<p>With this cache store, multiple server processes on the same host can share a
cache. This cache store is appropriate for low to medium traffic sites that are
served off one or two hosts. Server processes running on different hosts could
share a cache by using a shared file system, but that setup is not recommended.</p>

<p>As the cache will grow until the disk is full, it is recommended to
periodically clear out old entries.</p>

<h3 id="activesupportcachememcachestore"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::MemCacheStore</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/MemCacheStore.html"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::MemCacheStore</code></a> uses Danga’s <code class="language-plaintext highlighter-rouge">memcached</code> server to provide a centralized cache for your application. Rails uses the bundled <code class="language-plaintext highlighter-rouge">dalli</code> gem by default. This is currently the most popular cache store for production websites. It can be used to provide a single, shared cache cluster with very high performance and redundancy.</p>

<p>When initializing the cache, you should specify the addresses for all memcached servers in your cluster, or ensure the <code class="language-plaintext highlighter-rouge">MEMCACHE_SERVERS</code> environment variable has been set appropriately.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:mem_cache_store</span><span class="p">,</span> <span class="s2">"cache-1.example.com"</span><span class="p">,</span> <span class="s2">"cache-2.example.com"</span>
</code></pre></div></div>

<p>If neither are specified, it will assume memcached is running on localhost on the default port (<code class="language-plaintext highlighter-rouge">127.0.0.1:11211</code>), but this is not an ideal setup for larger sites.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:mem_cache_store</span> <span class="c1"># Will fallback to $MEMCACHE_SERVERS, then 127.0.0.1:11211</span>
</code></pre></div></div>

<p>See the <a href="https://www.rubydoc.info/gems/dalli/Dalli/Client#initialize-instance_method"><code class="language-plaintext highlighter-rouge">Dalli::Client</code> documentation</a> for supported address types.</p>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/MemCacheStore.html#method-i-write"><code class="language-plaintext highlighter-rouge">write</code></a> (and <code class="language-plaintext highlighter-rouge">fetch</code>) method on this cache accepts additional options that take advantage of features specific to memcached.</p>

<h3 id="activesupportcacherediscachestore"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::RedisCacheStore</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/RedisCacheStore.html"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::RedisCacheStore</code></a> takes advantage of Redis support for automatic eviction
when it reaches max memory, allowing it to behave much like a Memcached cache server.</p>

<p>Deployment note: Redis doesn’t expire keys by default, so take care to use a
dedicated Redis cache server. Don’t fill up your persistent-Redis server with
volatile cache data! Read the
<a href="https://redis.io/topics/lru-cache">Redis cache server setup guide</a> in detail.</p>

<p>For a cache-only Redis server, set <code class="language-plaintext highlighter-rouge">maxmemory-policy</code> to one of the variants of allkeys.
Redis 4+ supports least-frequently-used eviction (<code class="language-plaintext highlighter-rouge">allkeys-lfu</code>), an excellent
default choice. Redis 3 and earlier should use least-recently-used eviction (<code class="language-plaintext highlighter-rouge">allkeys-lru</code>).</p>

<p>Set cache read and write timeouts relatively low. Regenerating a cached value
is often faster than waiting more than a second to retrieve it. Both read and
write timeouts default to 1 second, but may be set lower if your network is
consistently low-latency.</p>

<p>By default, the cache store will attempt to reconnect to Redis once if the
connection fails during a request.</p>

<p>Cache reads and writes never raise exceptions; they just return <code class="language-plaintext highlighter-rouge">nil</code> instead,
behaving as if there was nothing in the cache. To gauge whether your cache is
hitting exceptions, you may provide an <code class="language-plaintext highlighter-rouge">error_handler</code> to report to an
exception gathering service. It must accept three keyword arguments: <code class="language-plaintext highlighter-rouge">method</code>,
the cache store method that was originally called; <code class="language-plaintext highlighter-rouge">returning</code>, the value that
was returned to the user, typically <code class="language-plaintext highlighter-rouge">nil</code>; and <code class="language-plaintext highlighter-rouge">exception</code>, the exception that
was rescued.</p>

<p>To get started, add the redis gem to your Gemfile:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span> <span class="s2">"redis"</span>
</code></pre></div></div>

<p>Finally, add the configuration in the relevant <code class="language-plaintext highlighter-rouge">config/environments/*.rb</code> file:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:redis_cache_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">url: </span><span class="no">ENV</span><span class="p">[</span><span class="s2">"REDIS_URL"</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<p>A more complex, production Redis cache store may look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cache_servers</span> <span class="o">=</span> <span class="sx">%w(redis://cache-01:6379/0 redis://cache-02:6379/0)</span>
<span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:redis_cache_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">url: </span><span class="n">cache_servers</span><span class="p">,</span>

  <span class="ss">connect_timeout:    </span><span class="mi">30</span><span class="p">,</span>  <span class="c1"># Defaults to 1 second</span>
  <span class="ss">read_timeout:       </span><span class="mf">0.2</span><span class="p">,</span> <span class="c1"># Defaults to 1 second</span>
  <span class="ss">write_timeout:      </span><span class="mf">0.2</span><span class="p">,</span> <span class="c1"># Defaults to 1 second</span>
  <span class="ss">reconnect_attempts: </span><span class="mi">2</span><span class="p">,</span>   <span class="c1"># Defaults to 1</span>

  <span class="ss">error_handler: </span><span class="o">-&gt;</span> <span class="p">(</span><span class="nb">method</span><span class="p">:,</span> <span class="n">returning</span><span class="p">:,</span> <span class="n">exception</span><span class="p">:)</span> <span class="p">{</span>
    <span class="c1"># Report errors to Sentry as warnings</span>
    <span class="no">Sentry</span><span class="p">.</span><span class="nf">capture_exception</span> <span class="n">exception</span><span class="p">,</span> <span class="ss">level: </span><span class="s2">"warning"</span><span class="p">,</span>
      <span class="ss">tags: </span><span class="p">{</span> <span class="ss">method: </span><span class="nb">method</span><span class="p">,</span> <span class="ss">returning: </span><span class="n">returning</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="activesupportcachenullstore"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::NullStore</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/NullStore.html"><code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::NullStore</code></a> is scoped to each web request, and clears stored values at the end of a request. It is meant for use in development and test environments. It can be very useful when you have code that interacts directly with <code class="language-plaintext highlighter-rouge">Rails.cache</code> but caching interferes with seeing the results of code changes.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:null_store</span>
</code></pre></div></div>

<h3 id="custom-cache-stores">Custom Cache Stores</h3>

<p>You can create your own custom cache store by simply extending
<code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::Store</code> and implementing the appropriate methods. This way,
you can swap in any number of caching technologies into your Rails application.</p>

<p>To use a custom cache store, simply set the cache store to a new instance of your
custom class.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="no">MyCacheStore</span><span class="p">.</span><span class="nf">new</span>
</code></pre></div></div>

<h2 id="cache-keys">Cache Keys</h2>

<p>The keys used in a cache can be any object that responds to either <code class="language-plaintext highlighter-rouge">cache_key</code> or
<code class="language-plaintext highlighter-rouge">to_param</code>. You can implement the <code class="language-plaintext highlighter-rouge">cache_key</code> method on your classes if you need
to generate custom keys. Active Record will generate keys based on the class name
and record id.</p>

<p>You can use Hashes and Arrays of values as cache keys.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This is a valid cache key</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="ss">site: </span><span class="s2">"mysite"</span><span class="p">,</span> <span class="ss">owners: </span><span class="p">[</span><span class="n">owner_1</span><span class="p">,</span> <span class="n">owner_2</span><span class="p">])</span>
</code></pre></div></div>

<p>The keys you use on <code class="language-plaintext highlighter-rouge">Rails.cache</code> will not be the same as those actually used with
the storage engine. They may be modified with a namespace or altered to fit
technology backend constraints. This means, for instance, that you can’t save
values with <code class="language-plaintext highlighter-rouge">Rails.cache</code> and then try to pull them out with the <code class="language-plaintext highlighter-rouge">dalli</code> gem.
However, you also don’t need to worry about exceeding the memcached size limit or
violating syntax rules.</p>

<h2 id="conditional-get-support">Conditional GET Support</h2>

<p>Conditional GETs are a feature of the HTTP specification that provide a way for web servers to tell browsers that the response to a GET request hasn’t changed since the last request and can be safely pulled from the browser cache.</p>

<p>They work by using the <code class="language-plaintext highlighter-rouge">HTTP_IF_NONE_MATCH</code> and <code class="language-plaintext highlighter-rouge">HTTP_IF_MODIFIED_SINCE</code> headers to pass back and forth both a unique content identifier and the timestamp of when the content was last changed. If the browser makes a request where the content identifier (ETag) or last modified since timestamp matches the server’s version then the server only needs to send back an empty response with a not modified status.</p>

<p>It is the server’s (i.e. our) responsibility to look for a last modified timestamp and the if-none-match header and determine whether or not to send back the full response. With conditional-get support in Rails this is a pretty easy task:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>

    <span class="c1"># If the request is stale according to the given timestamp and etag value</span>
    <span class="c1"># (i.e. it needs to be processed again) then execute this block</span>
    <span class="k">if</span> <span class="n">stale?</span><span class="p">(</span><span class="ss">last_modified: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">updated_at</span><span class="p">.</span><span class="nf">utc</span><span class="p">,</span> <span class="ss">etag: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">cache_key_with_version</span><span class="p">)</span>
      <span class="n">respond_to</span> <span class="k">do</span> <span class="o">|</span><span class="n">wants</span><span class="o">|</span>
        <span class="c1"># ... normal response processing</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># If the request is fresh (i.e. it's not modified) then you don't need to do</span>
    <span class="c1"># anything. The default render checks for this using the parameters</span>
    <span class="c1"># used in the previous call to stale? and will automatically send a</span>
    <span class="c1"># :not_modified. So that's it, you're done.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Instead of an options hash, you can also simply pass in a model. Rails will use the <code class="language-plaintext highlighter-rouge">updated_at</code> and <code class="language-plaintext highlighter-rouge">cache_key_with_version</code> methods for setting <code class="language-plaintext highlighter-rouge">last_modified</code> and <code class="language-plaintext highlighter-rouge">etag</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">stale?</span><span class="p">(</span><span class="vi">@product</span><span class="p">)</span>
      <span class="n">respond_to</span> <span class="k">do</span> <span class="o">|</span><span class="n">wants</span><span class="o">|</span>
        <span class="c1"># ... normal response processing</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you don’t have any special response processing and are using the default rendering mechanism (i.e. you’re not using <code class="language-plaintext highlighter-rouge">respond_to</code> or calling render yourself) then you’ve got an easy helper in <code class="language-plaintext highlighter-rouge">fresh_when</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="c1"># This will automatically send back a :not_modified if the request is fresh,</span>
  <span class="c1"># and will render the default template (product.*) if it's stale.</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
    <span class="n">fresh_when</span> <span class="ss">last_modified: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">published_at</span><span class="p">.</span><span class="nf">utc</span><span class="p">,</span> <span class="ss">etag: </span><span class="vi">@product</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When both <code class="language-plaintext highlighter-rouge">last_modified</code> and <code class="language-plaintext highlighter-rouge">etag</code> are set, behavior varies depending on the value of <code class="language-plaintext highlighter-rouge">config.action_dispatch.strict_freshness</code>.
If set to <code class="language-plaintext highlighter-rouge">true</code>, only the <code class="language-plaintext highlighter-rouge">etag</code> is considered as specified by RFC 7232 section 6.
If set to <code class="language-plaintext highlighter-rouge">false</code>, both are considered and the cache is considered fresh if both conditions are satisfied, as was the historical Rails behavior.</p>

<p>Sometimes we want to cache response, for example a static page, that never gets
expired. To achieve this, we can use <code class="language-plaintext highlighter-rouge">http_cache_forever</code> helper and by doing
so browser and proxies will cache it indefinitely.</p>

<p>By default cached responses will be private, cached only on the user’s web
browser. To allow proxies to cache the response, set <code class="language-plaintext highlighter-rouge">public: true</code> to indicate
that they can serve the cached response to all users.</p>

<p>Using this helper, <code class="language-plaintext highlighter-rouge">last_modified</code> header is set to <code class="language-plaintext highlighter-rouge">Time.new(2011, 1, 1).utc</code>
and <code class="language-plaintext highlighter-rouge">expires</code> header is set to a 100 years.</p>

<p>WARNING: Use this method carefully as browser/proxy won’t be able to invalidate
the cached response unless browser cache is forcefully cleared.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="n">http_cache_forever</span><span class="p">(</span><span class="ss">public: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">render</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="strong-vs-weak-etags">Strong v/s Weak ETags</h3>

<p>Rails generates weak ETags by default. Weak ETags allow semantically equivalent
responses to have the same ETags, even if their bodies do not match exactly.
This is useful when we don’t want the page to be regenerated for minor changes in
response body.</p>

<p>Weak ETags have a leading <code class="language-plaintext highlighter-rouge">W/</code> to differentiate them from strong ETags.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>W/"618bbc92e2d35ea1945008b42799b0e7" → Weak ETag
"618bbc92e2d35ea1945008b42799b0e7" → Strong ETag
</code></pre></div></div>

<p>Unlike weak ETag, strong ETag implies that response should be exactly the same
and byte by byte identical. Useful when doing Range requests within a
large video or PDF file. Some CDNs support only strong ETags, like Akamai.
If you absolutely need to generate a strong ETag, it can be done as follows.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
    <span class="n">fresh_when</span> <span class="ss">last_modified: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">published_at</span><span class="p">.</span><span class="nf">utc</span><span class="p">,</span> <span class="ss">strong_etag: </span><span class="vi">@product</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>You can also set the strong ETag directly on the response.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span><span class="p">.</span><span class="nf">strong_etag</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="nf">body</span> <span class="c1"># =&gt; "618bbc92e2d35ea1945008b42799b0e7"</span>
</code></pre></div></div>

        </div>

        <footer class="guide-footer">
            <div class="feedback">
                <h3>Geri Bildirim</h3>
                <p>Bu kılavuzun kalitesini artırmamıza yardımcı olmak için geri bildirimlerinizi bekliyoruz.</p>
                <p>Lütfen <a href="https://github.com/dilankaya127/rails-tr-TR">GitHub Issues</a> üzerinden katkıda bulunun.</p>
            </div>
        </footer>
    </article>
</div>

<script>
// İçindekiler tablosunu otomatik oluştur
document.addEventListener('DOMContentLoaded', function() {
    const toc = document.getElementById('toc');
    const headings = document.querySelectorAll('.guide-content h2, .guide-content h3, .guide-content h4');
    
    if (headings.length > 0) {
        const tocList = document.createElement('ul');
        
        headings.forEach(function(heading, index) {
            const id = 'heading-' + index;
            heading.id = id;
            
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#' + id;
            a.textContent = heading.textContent;
            a.className = 'toc-' + heading.tagName.toLowerCase();
            
            li.appendChild(a);
            tocList.appendChild(li);
        });
        
        toc.appendChild(tocList);
    }
});
</script>
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Rails Kılavuzları Türkçe Çevirisi. Gönüllüler tarafından hazırlanmıştır.</p>
            <p>Orijinal dokümantasyon <a href="https://guides.rubyonrails.org">Ruby on Rails</a> ekibine aittir.</p>
        </div>
    </footer>

    <script>hljs.highlightAll();</script>
</body>
</html>