<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Action Cable Overview - Rails Dokümantasyonu - Türkçe</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <h1 class="logo">
                    <a href="/">Rails Kılavuzları</a>
                </h1>
                <nav class="nav">
                    <a href="/">Ana Sayfa</a>
                    <a href="https://dilankaya127.github.io">Portföy</a>
                    <a href="https://github.com/dilankaya127/rails-tr-TR">GitHub</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="guide-container">
    <aside class="guide-sidebar">
        <div class="guide-toc">
            <h3>İçindekiler</h3>
            <div id="toc"></div>
        </div>
        
        <div class="guide-nav">
            <h3>Diğer Kılavuzlar</h3>
            <ul>
                <li><a href="/rails/guides/tr/getting_started">Rails ile Başlarken</a></li>
                <li><a href="/rails/guides/en/active_record_basics">Active Record Temelleri</a></li>
                <li><a href="/rails/guides//en/action_controller_overview">Action Controller</a></li>
                <li><a href="/rails/guides/tr/action_cable_overview">Action Cable</a></li>
            </ul>
        </div>
    </aside>

    <article class="guide-content">
        <header class="guide-header">
            <h1>Action Cable Overview</h1>
            
        </header>

        <div class="guide-body">
            <p><strong>DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p>

<h1 id="action-cable-overview">Action Cable Overview</h1>

<p>In this guide, you will learn how Action Cable works and how to use WebSockets to
incorporate real-time features into your Rails application.</p>

<p>After reading this guide, you will know:</p>

<ul>
  <li>What Action Cable is and its integration backend and frontend</li>
  <li>How to set up Action Cable</li>
  <li>How to set up channels</li>
  <li>Deployment and Architecture setup for running Action Cable</li>
</ul>

<hr />

<h2 id="what-is-action-cable">What is Action Cable?</h2>

<p>Action Cable seamlessly integrates
<a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> with the rest of your
Rails application. It allows for real-time features to be written in Ruby in the
same style and form as the rest of your Rails application, while still being
performant and scalable. It’s a full-stack offering that provides both a
client-side JavaScript framework and a server-side Ruby framework. You have
access to your entire domain model written with Active Record or your ORM of
choice.</p>

<h2 id="terminology">Terminology</h2>

<p>Action Cable uses WebSockets instead of the HTTP request-response protocol.
Both Action Cable and WebSockets introduce some less familiar terminology:</p>

<h3 id="connections">Connections</h3>

<p><em>Connections</em> form the foundation of the client-server relationship.
A single Action Cable server can handle multiple connection instances. It has one
connection instance per WebSocket connection. A single user may have multiple
WebSockets open to your application if they use multiple browser tabs or devices.</p>

<h3 id="consumers">Consumers</h3>

<p>The client of a WebSocket connection is called the <em>consumer</em>. In Action Cable,
the consumer is created by the client-side JavaScript framework.</p>

<h3 id="channels">Channels</h3>

<p>Each consumer can, in turn, subscribe to multiple <em>channels</em>. Each channel
encapsulates a logical unit of work, similar to what a controller does in
a typical MVC setup. For example, you could have a <code class="language-plaintext highlighter-rouge">ChatChannel</code> and
an <code class="language-plaintext highlighter-rouge">AppearancesChannel</code>, and a consumer could be subscribed to either
or both of these channels. At the very least, a consumer should be subscribed
to one channel.</p>

<h3 id="subscribers">Subscribers</h3>

<p>When the consumer is subscribed to a channel, they act as a <em>subscriber</em>.
The connection between the subscriber and the channel is, surprise-surprise,
called a subscription. A consumer can act as a subscriber to a given channel
any number of times. For example, a consumer could subscribe to multiple chat rooms
at the same time. (And remember that a physical user may have multiple consumers,
one per tab/device open to your connection).</p>

<h3 id="pubsub">Pub/Sub</h3>

<p><a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Pub/Sub</a> or
Publish-Subscribe refers to a message queue paradigm whereby senders of
information (publishers), send data to an abstract class of recipients
(subscribers), without specifying individual recipients. Action Cable uses this
approach to communicate between the server and many clients.</p>

<h3 id="broadcastings">Broadcastings</h3>

<p>A broadcasting is a pub/sub link where anything transmitted by the broadcaster is
sent directly to the channel subscribers who are streaming that named broadcasting.
Each channel can be streaming zero or more broadcastings.</p>

<h2 id="server-side-components">Server-Side Components</h2>

<h3 id="connections-1">Connections</h3>

<p>For every WebSocket accepted by the server, a connection object is instantiated. This
object becomes the parent of all the <em>channel subscriptions</em> that are created
from thereon. The connection itself does not deal with any specific application
logic beyond authentication and authorization. The client of a WebSocket
connection is called the connection <em>consumer</em>. An individual user will create
one consumer-connection pair per browser tab, window, or device they have open.</p>

<p>Connections are instances of <code class="language-plaintext highlighter-rouge">ApplicationCable::Connection</code>, which extends
<a href="https://api.rubyonrails.org/classes/ActionCable/Connection/Base.html"><code class="language-plaintext highlighter-rouge">ActionCable::Connection::Base</code></a>. In <code class="language-plaintext highlighter-rouge">ApplicationCable::Connection</code>, you
authorize the incoming connection and proceed to establish it if the user can
be identified.</p>

<h4 id="connection-setup">Connection Setup</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/application_cable/connection.rb</span>
<span class="k">module</span> <span class="nn">ApplicationCable</span>
  <span class="k">class</span> <span class="nc">Connection</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Connection</span><span class="o">::</span><span class="no">Base</span>
    <span class="n">identified_by</span> <span class="ss">:current_user</span>

    <span class="k">def</span> <span class="nf">connect</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="n">find_verified_user</span>
    <span class="k">end</span>

    <span class="kp">private</span>
      <span class="k">def</span> <span class="nf">find_verified_user</span>
        <span class="k">if</span> <span class="n">verified_user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">id: </span><span class="n">cookies</span><span class="p">.</span><span class="nf">encrypted</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">])</span>
          <span class="n">verified_user</span>
        <span class="k">else</span>
          <span class="n">reject_unauthorized_connection</span>
        <span class="k">end</span>
      <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here <a href="https://api.rubyonrails.org/classes/ActionCable/Connection/Identification/ClassMethods.html#method-i-identified_by"><code class="language-plaintext highlighter-rouge">identified_by</code></a> designates a connection identifier that can be used to find the
specific connection later. Note that anything marked as an identifier will automatically
create a delegate by the same name on any channel instances created off the connection.</p>

<p>This example relies on the fact that you will already have handled authentication of the user
somewhere else in your application, and that a successful authentication sets an encrypted
cookie with the user ID.</p>

<p>The cookie is then automatically sent to the connection instance when a new connection
is attempted, and you use that to set the <code class="language-plaintext highlighter-rouge">current_user</code>. By identifying the connection
by this same current user, you’re also ensuring that you can later retrieve all open
connections by a given user (and potentially disconnect them all if the user is deleted
or unauthorized).</p>

<p>If your authentication approach includes using a session, you use cookie store for the
session, your session cookie is named <code class="language-plaintext highlighter-rouge">_session</code> and the user ID key is <code class="language-plaintext highlighter-rouge">user_id</code> you
can use this approach:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">verified_user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">id: </span><span class="n">cookies</span><span class="p">.</span><span class="nf">encrypted</span><span class="p">[</span><span class="s2">"_session"</span><span class="p">][</span><span class="s2">"user_id"</span><span class="p">])</span>
</code></pre></div></div>

<h4 id="exception-handling">Exception Handling</h4>

<p>By default, unhandled exceptions are caught and logged to Rails’ logger. If you would like to
globally intercept these exceptions and report them to an external bug tracking service, for
example, you can do so with <a href="https://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html#method-i-rescue_from"><code class="language-plaintext highlighter-rouge">rescue_from</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/application_cable/connection.rb</span>
<span class="k">module</span> <span class="nn">ApplicationCable</span>
  <span class="k">class</span> <span class="nc">Connection</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Connection</span><span class="o">::</span><span class="no">Base</span>
    <span class="n">rescue_from</span> <span class="no">StandardError</span><span class="p">,</span> <span class="ss">with: :report_error</span>

    <span class="kp">private</span>
      <span class="k">def</span> <span class="nf">report_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="no">SomeExternalBugtrackingService</span><span class="p">.</span><span class="nf">notify</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
      <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="connection-callbacks">Connection Callbacks</h4>

<p><a href="https://api.rubyonrails.org/classes/ActionCable/Connection/Callbacks.html"><code class="language-plaintext highlighter-rouge">ActionCable::Connection::Callbacks</code></a> provides callback hooks that are
invoked when sending commands to the client, such as when subscribing,
unsubscribing, or performing an action:</p>

<ul>
  <li><a href="https://api.rubyonrails.org/classes/ActionCable/Connection/Callbacks/ClassMethods.html#method-i-before_command"><code class="language-plaintext highlighter-rouge">before_command</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActionCable/Connection/Callbacks/ClassMethods.html#method-i-after_command"><code class="language-plaintext highlighter-rouge">after_command</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActionCable/Connection/Callbacks/ClassMethods.html#method-i-around_command"><code class="language-plaintext highlighter-rouge">around_command</code></a></li>
</ul>

<h3 id="channels-1">Channels</h3>

<p>A <em>channel</em> encapsulates a logical unit of work, similar to what a controller does in a
typical MVC setup. By default, Rails creates a parent <code class="language-plaintext highlighter-rouge">ApplicationCable::Channel</code> class
(which extends <a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Base.html"><code class="language-plaintext highlighter-rouge">ActionCable::Channel::Base</code></a>) for encapsulating shared logic between your channels,
when you use the channel generator for the first time.</p>

<h4 id="parent-channel-setup">Parent Channel Setup</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/application_cable/channel.rb</span>
<span class="k">module</span> <span class="nn">ApplicationCable</span>
  <span class="k">class</span> <span class="nc">Channel</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Channel</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Your own channel classes could then look like these examples:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/chat_channel.rb</span>
<span class="k">class</span> <span class="nc">ChatChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/appearance_channel.rb</span>
<span class="k">class</span> <span class="nc">AppearanceChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A consumer could then be subscribed to either or both of these channels.</p>

<h4 id="subscriptions">Subscriptions</h4>

<p>Consumers subscribe to channels, acting as <em>subscribers</em>. Their connection is
called a <em>subscription</em>. Produced messages are then routed to these channel
subscriptions based on an identifier sent by the channel consumer.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/chat_channel.rb</span>
<span class="k">class</span> <span class="nc">ChatChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="c1"># Called when the consumer has successfully</span>
  <span class="c1"># become a subscriber to this channel.</span>
  <span class="k">def</span> <span class="nf">subscribed</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="exception-handling-1">Exception Handling</h4>

<p>As with <code class="language-plaintext highlighter-rouge">ApplicationCable::Connection</code>, you can also use <a href="https://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html#method-i-rescue_from"><code class="language-plaintext highlighter-rouge">rescue_from</code></a> on a
specific channel to handle raised exceptions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/chat_channel.rb</span>
<span class="k">class</span> <span class="nc">ChatChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="n">rescue_from</span> <span class="s2">"MyError"</span><span class="p">,</span> <span class="ss">with: :deliver_error_message</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">deliver_error_message</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
      <span class="c1"># broadcast_to(...)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="channel-callbacks">Channel Callbacks</h4>

<p><a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Callbacks.html"><code class="language-plaintext highlighter-rouge">ActionCable::Channel::Callbacks</code></a> provides callback hooks that are invoked
during the life cycle of a channel:</p>

<ul>
  <li><a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Callbacks/ClassMethods.html#method-i-before_subscribe"><code class="language-plaintext highlighter-rouge">before_subscribe</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Callbacks/ClassMethods.html#method-i-after_subscribe"><code class="language-plaintext highlighter-rouge">after_subscribe</code></a> (aliased as <a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Callbacks/ClassMethods.html#method-i-on_subscribe"><code class="language-plaintext highlighter-rouge">on_subscribe</code></a>)</li>
  <li><a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Callbacks/ClassMethods.html#method-i-before_unsubscribe"><code class="language-plaintext highlighter-rouge">before_unsubscribe</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Callbacks/ClassMethods.html#method-i-after_unsubscribe"><code class="language-plaintext highlighter-rouge">after_unsubscribe</code></a> (aliased as <a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Callbacks/ClassMethods.html#method-i-on_unsubscribe"><code class="language-plaintext highlighter-rouge">on_unsubscribe</code></a>)</li>
</ul>

<h2 id="client-side-components">Client-Side Components</h2>

<h3 id="connections-2">Connections</h3>

<p>Consumers require an instance of the connection on their side. This can be
established using the following JavaScript, which is generated by default by Rails:</p>

<h4 id="connect-consumer">Connect Consumer</h4>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/consumer.js</span>
<span class="c1">// Action Cable provides the framework to deal with WebSockets in Rails.</span>
<span class="c1">// You can generate new channels where WebSocket features live using the `bin/rails generate channel` command.</span>

<span class="k">import</span> <span class="p">{</span> <span class="nx">createConsumer</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@rails/actioncable</span><span class="dl">"</span>

<span class="k">export</span> <span class="k">default</span> <span class="nf">createConsumer</span><span class="p">()</span>
</code></pre></div></div>

<p>This will ready a consumer that’ll connect against <code class="language-plaintext highlighter-rouge">/cable</code> on your server by default.
The connection won’t be established until you’ve also specified at least one subscription
you’re interested in having.</p>

<p>The consumer can optionally take an argument that specifies the URL to connect to. This
can be a string or a function that returns a string that will be called when the
WebSocket is opened.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Specify a different URL to connect to</span>
<span class="nf">createConsumer</span><span class="p">(</span><span class="dl">'</span><span class="s1">wss://example.com/cable</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Or when using websockets over HTTP</span>
<span class="nf">createConsumer</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://ws.example.com/cable</span><span class="dl">'</span><span class="p">)</span>

<span class="c1">// Use a function to dynamically generate the URL</span>
<span class="nf">createConsumer</span><span class="p">(</span><span class="nx">getWebSocketURL</span><span class="p">)</span>

<span class="kd">function</span> <span class="nf">getWebSocketURL</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">auth-token</span><span class="dl">'</span><span class="p">)</span>
  <span class="k">return</span> <span class="s2">`wss://example.com/cable?token=</span><span class="p">${</span><span class="nx">token</span><span class="p">}</span><span class="s2">`</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="subscriber">Subscriber</h4>

<p>A consumer becomes a subscriber by creating a subscription to a given channel:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/chat_channel.js</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ChatChannel</span><span class="dl">"</span><span class="p">,</span> <span class="na">room</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Best Room</span><span class="dl">"</span> <span class="p">})</span>

<span class="c1">// app/javascript/channels/appearance_channel.js</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">AppearanceChannel</span><span class="dl">"</span> <span class="p">})</span>
</code></pre></div></div>

<p>While this creates the subscription, the functionality needed to respond to
received data will be described later on.</p>

<p>A consumer can act as a subscriber to a given channel any number of times. For
example, a consumer could subscribe to multiple chat rooms at the same time:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/chat_channel.js</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ChatChannel</span><span class="dl">"</span><span class="p">,</span> <span class="na">room</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1st Room</span><span class="dl">"</span> <span class="p">})</span>
<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ChatChannel</span><span class="dl">"</span><span class="p">,</span> <span class="na">room</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2nd Room</span><span class="dl">"</span> <span class="p">})</span>
</code></pre></div></div>

<h2 id="client-server-interactions">Client-Server Interactions</h2>

<h3 id="streams">Streams</h3>

<p><em>Streams</em> provide the mechanism by which channels route published content
(broadcasts) to their subscribers. For example, the following code uses
<a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Streams.html#method-i-stream_from"><code class="language-plaintext highlighter-rouge">stream_from</code></a> to subscribe to the broadcasting named <code class="language-plaintext highlighter-rouge">chat_Best Room</code> when
the value of the <code class="language-plaintext highlighter-rouge">:room</code> parameter is <code class="language-plaintext highlighter-rouge">"Best Room"</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/chat_channel.rb</span>
<span class="k">class</span> <span class="nc">ChatChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="k">def</span> <span class="nf">subscribed</span>
    <span class="n">stream_from</span> <span class="s2">"chat_</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:room</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then, elsewhere in your Rails application, you can broadcast to such a room by
calling <a href="https://api.rubyonrails.org/classes/ActionCable/Server/Broadcasting.html#method-i-broadcast"><code class="language-plaintext highlighter-rouge">broadcast</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ActionCable</span><span class="p">.</span><span class="nf">server</span><span class="p">.</span><span class="nf">broadcast</span><span class="p">(</span><span class="s2">"chat_Best Room"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">body: </span><span class="s2">"This Room is Best Room."</span> <span class="p">})</span>
</code></pre></div></div>

<p>If you have a stream that is related to a model, then the broadcasting name
can be generated from the channel and model. For example, the following code
uses <a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Streams.html#method-i-stream_for"><code class="language-plaintext highlighter-rouge">stream_for</code></a> to subscribe to a broadcasting like
<code class="language-plaintext highlighter-rouge">posts:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE</code>, where <code class="language-plaintext highlighter-rouge">Z2lkOi8vVGVzdEFwcC9Qb3N0LzE</code> is
the GlobalID of the Post model.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PostsChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="k">def</span> <span class="nf">subscribed</span>
    <span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
    <span class="n">stream_for</span> <span class="n">post</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>You can then broadcast to this channel by calling <a href="https://api.rubyonrails.org/classes/ActionCable/Channel/Broadcasting/ClassMethods.html#method-i-broadcast_to"><code class="language-plaintext highlighter-rouge">broadcast_to</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">PostsChannel</span><span class="p">.</span><span class="nf">broadcast_to</span><span class="p">(</span><span class="vi">@post</span><span class="p">,</span> <span class="vi">@comment</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="broadcastings-1">Broadcastings</h3>

<p>A <em>broadcasting</em> is a pub/sub link where anything transmitted by a publisher
is routed directly to the channel subscribers who are streaming that named
broadcasting. Each channel can be streaming zero or more broadcastings.</p>

<p>Broadcastings are purely an online queue and time-dependent. If a consumer is
not streaming (subscribed to a given channel), they’ll not get the broadcast
should they connect later.</p>

<h3 id="subscriptions-1">Subscriptions</h3>

<p>When a consumer is subscribed to a channel, they act as a subscriber. This
connection is called a subscription. Incoming messages are then routed to
these channel subscriptions based on an identifier sent by the cable consumer.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/chat_channel.js</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ChatChannel</span><span class="dl">"</span><span class="p">,</span> <span class="na">room</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Best Room</span><span class="dl">"</span> <span class="p">},</span> <span class="p">{</span>
  <span class="nf">received</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">appendLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="nf">appendLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">html</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">createLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">[data-chat-room='Best Room']</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">element</span><span class="p">.</span><span class="nf">insertAdjacentHTML</span><span class="p">(</span><span class="dl">"</span><span class="s2">beforeend</span><span class="dl">"</span><span class="p">,</span> <span class="nx">html</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="nf">createLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`
      &lt;article class="chat-line"&gt;
        &lt;span class="speaker"&gt;</span><span class="p">${</span><span class="nx">data</span><span class="p">[</span><span class="dl">"</span><span class="s2">sent_by</span><span class="dl">"</span><span class="p">]}</span><span class="s2">&lt;/span&gt;
        &lt;span class="body"&gt;</span><span class="p">${</span><span class="nx">data</span><span class="p">[</span><span class="dl">"</span><span class="s2">body</span><span class="dl">"</span><span class="p">]}</span><span class="s2">&lt;/span&gt;
      &lt;/article&gt;
    `</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<h3 id="passing-parameters-to-channels">Passing Parameters to Channels</h3>

<p>You can pass parameters from the client-side to the server-side when creating a
subscription. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/chat_channel.rb</span>
<span class="k">class</span> <span class="nc">ChatChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="k">def</span> <span class="nf">subscribed</span>
    <span class="n">stream_from</span> <span class="s2">"chat_</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:room</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>An object passed as the first argument to <code class="language-plaintext highlighter-rouge">subscriptions.create</code> becomes the
params hash in the cable channel. The keyword <code class="language-plaintext highlighter-rouge">channel</code> is required:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/chat_channel.js</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ChatChannel</span><span class="dl">"</span><span class="p">,</span> <span class="na">room</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Best Room</span><span class="dl">"</span> <span class="p">},</span> <span class="p">{</span>
  <span class="nf">received</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">appendLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="nf">appendLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">html</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">createLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">[data-chat-room='Best Room']</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">element</span><span class="p">.</span><span class="nf">insertAdjacentHTML</span><span class="p">(</span><span class="dl">"</span><span class="s2">beforeend</span><span class="dl">"</span><span class="p">,</span> <span class="nx">html</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="nf">createLine</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`
      &lt;article class="chat-line"&gt;
        &lt;span class="speaker"&gt;</span><span class="p">${</span><span class="nx">data</span><span class="p">[</span><span class="dl">"</span><span class="s2">sent_by</span><span class="dl">"</span><span class="p">]}</span><span class="s2">&lt;/span&gt;
        &lt;span class="body"&gt;</span><span class="p">${</span><span class="nx">data</span><span class="p">[</span><span class="dl">"</span><span class="s2">body</span><span class="dl">"</span><span class="p">]}</span><span class="s2">&lt;/span&gt;
      &lt;/article&gt;
    `</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Somewhere in your app this is called, perhaps</span>
<span class="c1"># from a NewCommentJob.</span>
<span class="no">ActionCable</span><span class="p">.</span><span class="nf">server</span><span class="p">.</span><span class="nf">broadcast</span><span class="p">(</span>
  <span class="s2">"chat_</span><span class="si">#{</span><span class="n">room</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="ss">sent_by: </span><span class="s2">"Paul"</span><span class="p">,</span>
    <span class="ss">body: </span><span class="s2">"This is a cool chat app."</span>
  <span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<h3 id="rebroadcasting-a-message">Rebroadcasting a Message</h3>

<p>A common use case is to <em>rebroadcast</em> a message sent by one client to any
other connected clients.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/chat_channel.rb</span>
<span class="k">class</span> <span class="nc">ChatChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="k">def</span> <span class="nf">subscribed</span>
    <span class="n">stream_from</span> <span class="s2">"chat_</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:room</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="no">ActionCable</span><span class="p">.</span><span class="nf">server</span><span class="p">.</span><span class="nf">broadcast</span><span class="p">(</span><span class="s2">"chat_</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:room</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/chat_channel.js</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="kd">const</span> <span class="nx">chatChannel</span> <span class="o">=</span> <span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ChatChannel</span><span class="dl">"</span><span class="p">,</span> <span class="na">room</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Best Room</span><span class="dl">"</span> <span class="p">},</span> <span class="p">{</span>
  <span class="nf">received</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// data =&gt; { sent_by: "Paul", body: "This is a cool chat app." }</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="nx">chatChannel</span><span class="p">.</span><span class="nf">send</span><span class="p">({</span> <span class="na">sent_by</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Paul</span><span class="dl">"</span><span class="p">,</span> <span class="na">body</span><span class="p">:</span> <span class="dl">"</span><span class="s2">This is a cool chat app.</span><span class="dl">"</span> <span class="p">})</span>
</code></pre></div></div>

<p>The rebroadcast will be received by all connected clients, <em>including</em> the
client that sent the message. Note that params are the same as they were when
you subscribed to the channel.</p>

<h2 id="full-stack-examples">Full-Stack Examples</h2>

<p>The following setup steps are common to both examples:</p>

<ol>
  <li><a href="#connection-setup">Set up your connection</a>.</li>
  <li><a href="#parent-channel-setup">Set up your parent channel</a>.</li>
  <li><a href="#connect-consumer">Connect your consumer</a>.</li>
</ol>

<h3 id="example-1-user-appearances">Example 1: User Appearances</h3>

<p>Here’s a simple example of a channel that tracks whether a user is online or not
and what page they’re on. (This is useful for creating presence features like showing
a green dot next to a username if they’re online).</p>

<p>Create the server-side appearance channel:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/appearance_channel.rb</span>
<span class="k">class</span> <span class="nc">AppearanceChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="k">def</span> <span class="nf">subscribed</span>
    <span class="n">current_user</span><span class="p">.</span><span class="nf">appear</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">unsubscribed</span>
    <span class="n">current_user</span><span class="p">.</span><span class="nf">disappear</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">appear</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">current_user</span><span class="p">.</span><span class="nf">appear</span><span class="p">(</span><span class="ss">on: </span><span class="n">data</span><span class="p">[</span><span class="s2">"appearing_on"</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">away</span>
    <span class="n">current_user</span><span class="p">.</span><span class="nf">away</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When a subscription is initiated the <code class="language-plaintext highlighter-rouge">subscribed</code> callback gets fired, and we
take that opportunity to say “the current user has indeed appeared”. That
appear/disappear API could be backed by Redis, a database, or whatever else.</p>

<p>Create the client-side appearance channel subscription:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/appearance_channel.js</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="dl">"</span><span class="s2">AppearanceChannel</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// Called once when the subscription is created.</span>
  <span class="nf">initialized</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">update</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="c1">// Called when the subscription is ready for use on the server.</span>
  <span class="nf">connected</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">install</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">update</span><span class="p">()</span>
  <span class="p">},</span>

  <span class="c1">// Called when the WebSocket connection is closed.</span>
  <span class="nf">disconnected</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">uninstall</span><span class="p">()</span>
  <span class="p">},</span>

  <span class="c1">// Called when the subscription is rejected by the server.</span>
  <span class="nf">rejected</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">uninstall</span><span class="p">()</span>
  <span class="p">},</span>

  <span class="nf">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">documentIsActive</span> <span class="p">?</span> <span class="k">this</span><span class="p">.</span><span class="nf">appear</span><span class="p">()</span> <span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nf">away</span><span class="p">()</span>
  <span class="p">},</span>

  <span class="nf">appear</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Calls `AppearanceChannel#appear(data)` on the server.</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">perform</span><span class="p">(</span><span class="dl">"</span><span class="s2">appear</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span> <span class="na">appearing_on</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appearingOn</span> <span class="p">})</span>
  <span class="p">},</span>

  <span class="nf">away</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Calls `AppearanceChannel#away` on the server.</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">perform</span><span class="p">(</span><span class="dl">"</span><span class="s2">away</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="nf">install</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">focus</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">blur</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
    <span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">turbo:load</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
    <span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">visibilitychange</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="nf">uninstall</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">focus</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">blur</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
    <span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">turbo:load</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
    <span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">visibilitychange</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="kd">get</span> <span class="nf">documentIsActive</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">document</span><span class="p">.</span><span class="nx">visibilityState</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">visible</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nb">document</span><span class="p">.</span><span class="nf">hasFocus</span><span class="p">()</span>
  <span class="p">},</span>

  <span class="kd">get</span> <span class="nf">appearingOn</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">[data-appearing-on]</span><span class="dl">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">element</span> <span class="p">?</span> <span class="nx">element</span><span class="p">.</span><span class="nf">getAttribute</span><span class="p">(</span><span class="dl">"</span><span class="s2">data-appearing-on</span><span class="dl">"</span><span class="p">)</span> <span class="p">:</span> <span class="kc">null</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<h4 id="client-server-interaction">Client-Server Interaction</h4>

<ol>
  <li>
    <p><strong>Client</strong> connects to the <strong>Server</strong> via <code class="language-plaintext highlighter-rouge">createConsumer()</code>. (<code class="language-plaintext highlighter-rouge">consumer.js</code>). The
  <strong>Server</strong> identifies this connection by <code class="language-plaintext highlighter-rouge">current_user</code>.</p>
  </li>
  <li>
    <p><strong>Client</strong> subscribes to the appearance channel via
  <code class="language-plaintext highlighter-rouge">consumer.subscriptions.create({ channel: "AppearanceChannel" })</code>. (<code class="language-plaintext highlighter-rouge">appearance_channel.js</code>)</p>
  </li>
  <li>
    <p><strong>Server</strong> recognizes a new subscription has been initiated for the
  appearance channel and runs its <code class="language-plaintext highlighter-rouge">subscribed</code> callback, calling the <code class="language-plaintext highlighter-rouge">appear</code>
  method on <code class="language-plaintext highlighter-rouge">current_user</code>. (<code class="language-plaintext highlighter-rouge">appearance_channel.rb</code>)</p>
  </li>
  <li>
    <p><strong>Client</strong> recognizes that a subscription has been established and calls
  <code class="language-plaintext highlighter-rouge">connected</code> (<code class="language-plaintext highlighter-rouge">appearance_channel.js</code>), which in turn calls <code class="language-plaintext highlighter-rouge">install</code> and <code class="language-plaintext highlighter-rouge">appear</code>.
  <code class="language-plaintext highlighter-rouge">appear</code> calls <code class="language-plaintext highlighter-rouge">AppearanceChannel#appear(data)</code> on the server, and supplies a
  data hash of <code class="language-plaintext highlighter-rouge">{ appearing_on: this.appearingOn }</code>. This is
  possible because the server-side channel instance automatically exposes all
  public methods declared on the class (minus the callbacks), so that these can be
  reached as remote procedure calls via a subscription’s <code class="language-plaintext highlighter-rouge">perform</code> method.</p>
  </li>
  <li>
    <p><strong>Server</strong> receives the request for the <code class="language-plaintext highlighter-rouge">appear</code> action on the appearance
  channel for the connection identified by <code class="language-plaintext highlighter-rouge">current_user</code>
  (<code class="language-plaintext highlighter-rouge">appearance_channel.rb</code>). <strong>Server</strong> retrieves the data with the
  <code class="language-plaintext highlighter-rouge">:appearing_on</code> key from the data hash and sets it as the value for the <code class="language-plaintext highlighter-rouge">:on</code>
  key being passed to <code class="language-plaintext highlighter-rouge">current_user.appear</code>.</p>
  </li>
</ol>

<h3 id="example-2-receiving-new-web-notifications">Example 2: Receiving New Web Notifications</h3>

<p>The appearance example was all about exposing server functionality to
client-side invocation over the WebSocket connection. But the great thing
about WebSockets is that it’s a two-way street. So, now, let’s show an example
where the server invokes an action on the client.</p>

<p>This is a web notification channel that allows you to trigger client-side
web notifications when you broadcast to the relevant streams:</p>

<p>Create the server-side web notifications channel:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/channels/web_notifications_channel.rb</span>
<span class="k">class</span> <span class="nc">WebNotificationsChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>
  <span class="k">def</span> <span class="nf">subscribed</span>
    <span class="n">stream_for</span> <span class="n">current_user</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Create the client-side web notifications channel subscription:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/javascript/channels/web_notifications_channel.js</span>
<span class="c1">// Client-side which assumes you've already requested</span>
<span class="c1">// the right to send web notifications.</span>
<span class="k">import</span> <span class="nx">consumer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./consumer</span><span class="dl">"</span>

<span class="nx">consumer</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="dl">"</span><span class="s2">WebNotificationsChannel</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="nf">received</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="nc">Notification</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="dl">"</span><span class="s2">title</span><span class="dl">"</span><span class="p">],</span> <span class="p">{</span> <span class="na">body</span><span class="p">:</span> <span class="nx">data</span><span class="p">[</span><span class="dl">"</span><span class="s2">body</span><span class="dl">"</span><span class="p">]</span> <span class="p">})</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Broadcast content to a web notification channel instance from elsewhere in your
application:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Somewhere in your app this is called, perhaps from a NewCommentJob</span>
<span class="no">WebNotificationsChannel</span><span class="p">.</span><span class="nf">broadcast_to</span><span class="p">(</span>
  <span class="n">current_user</span><span class="p">,</span>
  <span class="ss">title: </span><span class="s2">"New things!"</span><span class="p">,</span>
  <span class="ss">body: </span><span class="s2">"All the news fit to print"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">WebNotificationsChannel.broadcast_to</code> call places a message in the current
subscription adapter’s pubsub queue under a separate broadcasting name for each
user. For a user with an ID of 1, the broadcasting name would be
<code class="language-plaintext highlighter-rouge">web_notifications:1</code>.</p>

<p>The channel has been instructed to stream everything that arrives at
<code class="language-plaintext highlighter-rouge">web_notifications:1</code> directly to the client by invoking the <code class="language-plaintext highlighter-rouge">received</code>
callback. The data passed as an argument is the hash sent as the second parameter
to the server-side broadcast call, JSON encoded for the trip across the wire
and unpacked for the data argument arriving as <code class="language-plaintext highlighter-rouge">received</code>.</p>

<h3 id="more-complete-examples">More Complete Examples</h3>

<p>See the <a href="https://github.com/rails/actioncable-examples">rails/actioncable-examples</a>
repository for a full example of how to set up Action Cable in a Rails app and adding channels.</p>

<h2 id="configuration">Configuration</h2>

<p>Action Cable has two required configurations: a subscription adapter and allowed request origins.</p>

<h3 id="subscription-adapter">Subscription Adapter</h3>

<p>By default, Action Cable looks for a configuration file in <code class="language-plaintext highlighter-rouge">config/cable.yml</code>.
The file must specify an adapter for each Rails environment. See the
<a href="#dependencies">Dependencies</a> section for additional information on adapters.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">development</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">async</span>

<span class="na">test</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">test</span>

<span class="na">production</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">redis</span>
  <span class="na">url</span><span class="pi">:</span> <span class="s">redis://10.10.3.153:6381</span>
  <span class="na">channel_prefix</span><span class="pi">:</span> <span class="s">appname_production</span>
</code></pre></div></div>

<h4 id="adapter-configuration">Adapter Configuration</h4>

<p>Below is a list of the subscription adapters available for end-users.</p>

<h5 id="async-adapter">Async Adapter</h5>

<p>The async adapter is intended for development/testing and should not be used in production.</p>

<p>NOTE: The async adapter only works within the same process, so for manually triggering cable updates from a console and seeing results in the browser, you must do so from the web console (running inside the dev process), not a terminal started via <code class="language-plaintext highlighter-rouge">bin/rails console</code>! Add <code class="language-plaintext highlighter-rouge">console</code> to any action or any ERB template view to make the web console appear.</p>

<h5 id="solid-cable-adapter">Solid Cable Adapter</h5>

<p>The Solid Cable adapter is a database-backed solution that uses Active Record. It has been tested with MySQL, SQLite, and PostgreSQL. Running <code class="language-plaintext highlighter-rouge">bin/rails solid_cable:install</code> will automatically set up <code class="language-plaintext highlighter-rouge">config/cable.yml</code> and create <code class="language-plaintext highlighter-rouge">db/cable_schema.rb</code>. After that, you must manually update <code class="language-plaintext highlighter-rouge">config/database.yml</code>, adjusting it based on your database. See <a href="https://github.com/rails/solid_cable?tab=readme-ov-file#installation">Solid Cable Installation</a>.</p>

<h5 id="redis-adapter">Redis Adapter</h5>

<p>The Redis adapter requires users to provide a URL pointing to the Redis server.
Additionally, a <code class="language-plaintext highlighter-rouge">channel_prefix</code> may be provided to avoid channel name collisions
when using the same Redis server for multiple applications. See the <a href="https://redis.io/docs/manual/pubsub/#database--scoping">Redis Pub/Sub documentation</a> for more details.</p>

<p>The Redis adapter also supports SSL/TLS connections. The required SSL/TLS parameters can be passed in <code class="language-plaintext highlighter-rouge">ssl_params</code> key in the configuration YAML file.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">production</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">redis</span>
  <span class="na">url</span><span class="pi">:</span> <span class="s">rediss://10.10.3.153:tls_port</span>
  <span class="na">channel_prefix</span><span class="pi">:</span> <span class="s">appname_production</span>
  <span class="na">ssl_params</span><span class="pi">:</span>
    <span class="na">ca_file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/path/to/ca.crt"</span>
</code></pre></div></div>

<p>The options given to <code class="language-plaintext highlighter-rouge">ssl_params</code> are passed directly to the <code class="language-plaintext highlighter-rouge">OpenSSL::SSL::SSLContext#set_params</code> method and can be any valid attribute of the SSL context.
Please refer to the <a href="https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html">OpenSSL::SSL::SSLContext documentation</a> for other available attributes.</p>

<p>If you are using self-signed certificates for redis adapter behind a firewall and opt to skip certificate check, then the ssl <code class="language-plaintext highlighter-rouge">verify_mode</code> should be set as <code class="language-plaintext highlighter-rouge">OpenSSL::SSL::VERIFY_NONE</code>.</p>

<p>WARNING: It is not recommended to use <code class="language-plaintext highlighter-rouge">VERIFY_NONE</code> in production unless you absolutely understand the security implications. In order to set this option for the Redis adapter, the config should be <code class="language-plaintext highlighter-rouge">ssl_params: { verify_mode: &lt;%= OpenSSL::SSL::VERIFY_NONE %&gt; }</code>.</p>

<h5 id="postgresql-adapter">PostgreSQL Adapter</h5>

<p>The PostgreSQL adapter uses Active Record’s connection pool, and thus the
application’s <code class="language-plaintext highlighter-rouge">config/database.yml</code> database configuration, for its connection.
This may change in the future. <a href="https://github.com/rails/rails/issues/27214">#27214</a></p>

<p>NOTE: PostgreSQL has a <a href="https://www.postgresql.org/docs/current/sql-notify.html">8000 bytes limit</a> on <code class="language-plaintext highlighter-rouge">NOTIFY</code> (the command used under the hood for sending notifications) which might be a constraint when dealing with large payloads.</p>

<h3 id="allowed-request-origins">Allowed Request Origins</h3>

<p>Action Cable will only accept requests from specified origins, which are
passed to the server config as an array. The origins can be instances of
strings or regular expressions, against which a check for the match will be performed.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">allowed_request_origins</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"https://rubyonrails.com"</span><span class="p">,</span> <span class="sr">%r{http://ruby.*}</span><span class="p">]</span>
</code></pre></div></div>

<p>To disable and allow requests from any origin:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">disable_request_forgery_protection</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre></div></div>

<p>By default, Action Cable allows all requests from localhost:3000 when running
in the development environment.</p>

<h3 id="consumer-configuration">Consumer Configuration</h3>

<p>To configure the URL, add a call to <a href="https://api.rubyonrails.org/classes/ActionCable/Helpers/ActionCableHelper.html#method-i-action_cable_meta_tag"><code class="language-plaintext highlighter-rouge">action_cable_meta_tag</code></a> in your HTML layout
HEAD. This uses a URL or path typically set via <a href="configuring.html#config-action-cable-url"><code class="language-plaintext highlighter-rouge">config.action_cable.url</code></a> in the
environment configuration files.</p>

<h3 id="worker-pool-configuration">Worker Pool Configuration</h3>

<p>The worker pool is used to run connection callbacks and channel actions in
isolation from the server’s main thread. Action Cable allows the application
to configure the number of simultaneously processed threads in the worker pool.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">worker_pool_size</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div></div>

<p>Also, note that your server must provide at least the same number of database
connections as you have workers. The default worker pool size is set to 4, so
that means you have to make at least 4 database connections available.
You can change that in <code class="language-plaintext highlighter-rouge">config/database.yml</code> through the <code class="language-plaintext highlighter-rouge">pool</code> attribute.</p>

<h3 id="client-side-logging">Client-side Logging</h3>

<p>Client-side logging is disabled by default. You can enable this by setting the <code class="language-plaintext highlighter-rouge">ActionCable.logger.enabled</code> to true.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">ActionCable</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@rails/actioncable</span><span class="dl">'</span>

<span class="nx">ActionCable</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">=</span> <span class="kc">true</span>
</code></pre></div></div>

<h3 id="other-configurations">Other Configurations</h3>

<p>The other common option to configure is the log tags applied to the
per-connection logger. Here’s an example that uses
the user account id if available, else “no-account” while tagging:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">log_tags</span> <span class="o">=</span> <span class="p">[</span>
  <span class="o">-&gt;</span> <span class="n">request</span> <span class="p">{</span> <span class="n">request</span><span class="p">.</span><span class="nf">env</span><span class="p">[</span><span class="s2">"user_account_id"</span><span class="p">]</span> <span class="o">||</span> <span class="s2">"no-account"</span> <span class="p">},</span>
  <span class="ss">:action_cable</span><span class="p">,</span>
  <span class="o">-&gt;</span> <span class="n">request</span> <span class="p">{</span> <span class="n">request</span><span class="p">.</span><span class="nf">uuid</span> <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>

<p>For a full list of all configuration options, see the
<code class="language-plaintext highlighter-rouge">ActionCable::Server::Configuration</code> class.</p>

<h2 id="running-standalone-cable-servers">Running Standalone Cable Servers</h2>

<p>Action Cable can either run as part of your Rails application, or as
a standalone server. In development, running as part of your Rails app
is generally fine, but in production you should run it as a standalone.</p>

<h3 id="in-app">In App</h3>

<p>Action Cable can run alongside your Rails application. For example, to
listen for WebSocket requests on <code class="language-plaintext highlighter-rouge">/websocket</code>, specify that path to
<a href="configuring.html#config-action-cable-mount-path"><code class="language-plaintext highlighter-rouge">config.action_cable.mount_path</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/application.rb</span>
<span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">mount_path</span> <span class="o">=</span> <span class="s2">"/websocket"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>You can use <code class="language-plaintext highlighter-rouge">ActionCable.createConsumer()</code> to connect to the cable
server if <a href="https://api.rubyonrails.org/classes/ActionCable/Helpers/ActionCableHelper.html#method-i-action_cable_meta_tag"><code class="language-plaintext highlighter-rouge">action_cable_meta_tag</code></a> is invoked in the layout. Otherwise, a path is
specified as first argument to <code class="language-plaintext highlighter-rouge">createConsumer</code> (e.g. <code class="language-plaintext highlighter-rouge">ActionCable.createConsumer("/websocket")</code>).</p>

<p>For every instance of your server you create, and for every worker your server
spawns, you will also have a new instance of Action Cable, but the Redis or
PostgreSQL adapter keeps messages synced across connections.</p>

<h3 id="standalone">Standalone</h3>

<p>The cable servers can be separated from your normal application server. It’s
still a Rack application, but it is its own Rack application. The recommended
basic setup is as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># cable/config.ru</span>
<span class="nb">require_relative</span> <span class="s2">"../config/environment"</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>

<span class="n">run</span> <span class="no">ActionCable</span><span class="p">.</span><span class="nf">server</span>
</code></pre></div></div>

<p>Then to start the server:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bundle <span class="nb">exec </span>puma <span class="nt">-p</span> 28080 cable/config.ru
</code></pre></div></div>

<p>This starts a cable server on port 28080. To tell Rails to use this
server, update your config:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/environments/development.rb</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">configure</span> <span class="k">do</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">mount_path</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">url</span> <span class="o">=</span> <span class="s2">"ws://localhost:28080"</span> <span class="c1"># use wss:// in production</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Finally, ensure you have <a href="#consumer-configuration">configured the consumer correctly</a>.</p>

<h3 id="notes">Notes</h3>

<p>The WebSocket server doesn’t have access to the session, but it has
access to the cookies. This can be used when you need to handle
authentication. You can see one way of doing that with Devise in this <a href="https://greg.molnar.io/blog/actioncable-devise-authentication/">article</a>.</p>

<h2 id="dependencies">Dependencies</h2>

<p>Action Cable provides a subscription adapter interface to process its
pubsub internals. By default, asynchronous, inline, PostgreSQL, and Redis
adapters are included. The default adapter
in new Rails applications is the asynchronous (<code class="language-plaintext highlighter-rouge">async</code>) adapter.</p>

<p>The Ruby side of things is built on top of <a href="https://github.com/faye/websocket-driver-ruby">websocket-driver</a>,
<a href="https://github.com/celluloid/nio4r">nio4r</a>, and <a href="https://github.com/ruby-concurrency/concurrent-ruby">concurrent-ruby</a>.</p>

<h2 id="deployment">Deployment</h2>

<p>Action Cable is powered by a combination of WebSockets and threads. Both the
framework plumbing and user-specified channel work are handled internally by
utilizing Ruby’s native thread support. This means you can use all your existing
Rails models with no problem, as long as you haven’t committed any thread-safety sins.</p>

<p>The Action Cable server implements the Rack socket hijacking API,
thereby allowing the use of a multi-threaded pattern for managing connections
internally, irrespective of whether the application server is multi-threaded or not.</p>

<p>Accordingly, Action Cable works with popular servers like Unicorn, Puma, and
Passenger.</p>

<h2 id="testing">Testing</h2>

<p>You can find detailed instructions on how to test your Action Cable functionality in the
<a href="testing.html#testing-action-cable">testing guide</a>.</p>

        </div>

        <footer class="guide-footer">
            <div class="feedback">
                <h3>Geri Bildirim</h3>
                <p>Bu kılavuzun kalitesini artırmamıza yardımcı olmak için geri bildirimlerinizi bekliyoruz.</p>
                <p>Lütfen <a href="https://github.com/dilankaya127/rails-tr-TR">GitHub Issues</a> üzerinden katkıda bulunun.</p>
            </div>
        </footer>
    </article>
</div>

<script>
// İçindekiler tablosunu otomatik oluştur
document.addEventListener('DOMContentLoaded', function() {
    const toc = document.getElementById('toc');
    const headings = document.querySelectorAll('.guide-content h2, .guide-content h3, .guide-content h4');
    
    if (headings.length > 0) {
        const tocList = document.createElement('ul');
        
        headings.forEach(function(heading, index) {
            const id = 'heading-' + index;
            heading.id = id;
            
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#' + id;
            a.textContent = heading.textContent;
            a.className = 'toc-' + heading.tagName.toLowerCase();
            
            li.appendChild(a);
            tocList.appendChild(li);
        });
        
        toc.appendChild(tocList);
    }
});
</script>
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Rails Kılavuzları Türkçe Çevirisi. Gönüllüler tarafından hazırlanmıştır.</p>
            <p>Orijinal dokümantasyon <a href="https://guides.rubyonrails.org">Ruby on Rails</a> ekibine aittir.</p>
        </div>
    </footer>

    <script>hljs.highlightAll();</script>
</body>
</html>