<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Record Querying - Rails Dokümantasyonu - Türkçe</title>
    <link rel="stylesheet" href="/rails-tr-TR/assets/css/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <h1 class="logo">
                    <a href="/rails-tr-TR/">Rails Kılavuzları</a>
                </h1>
                <nav class="nav">
                    <a href="/rails-tr-TR/">Ana Sayfa</a>
                    <a href="https://dilankaya127.github.io">Portföy</a>
                    <a href="https://github.com/dilankaya127/rails-tr-TR">GitHub</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="guide-container">
    <aside class="guide-sidebar">
        <div class="guide-toc">
            <h3>İçindekiler</h3>
            <div id="toc"></div>
        </div>
        
        <div class="guide-nav">
            <h3>Diğer Kılavuzlar</h3>
            <ul>
                <li><a href="/rails-tr-TR/guides/tr/getting_started">Rails ile Başlarken</a></li>
                <li><a href="/rails-tr-TR/guides/en/active_record_basics">Active Record Temelleri</a></li>
                <li><a href="/rails-tr-TR/guides//en/action_controller_overview">Action Controller</a></li>
                <li><a href="/rails-tr-TR/guides/tr/action_cable_overview">Action Cable</a></li>
            </ul>
        </div>
    </aside>

    <article class="guide-content">
        <header class="guide-header">
            <h1>Active Record Querying</h1>
            
        </header>

        <div class="guide-body">
            <p><strong>DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p>

<h1 id="active-record-query-interface">Active Record Query Interface</h1>

<p>This guide covers different ways to retrieve data from the database using Active Record.</p>

<p>After reading this guide, you will know:</p>

<ul>
  <li>How to find records using a variety of methods and conditions.</li>
  <li>How to specify the order, retrieved attributes, grouping, and other properties of the found records.</li>
  <li>How to use eager loading to reduce the number of database queries needed for data retrieval.</li>
  <li>How to use dynamic finder methods.</li>
  <li>How to use method chaining to use multiple Active Record methods together.</li>
  <li>How to check for the existence of particular records.</li>
  <li>How to perform various calculations on Active Record models.</li>
  <li>How to run EXPLAIN on relations.</li>
</ul>

<hr />

<h2 id="what-is-the-active-record-query-interface">What is the Active Record Query Interface?</h2>

<p>If you’re used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.</p>

<p>Active Record will perform queries on the database for you and is compatible with most database systems, including MySQL, MariaDB, PostgreSQL, and SQLite. Regardless of which database system you’re using, the Active Record method format will always be the same.</p>

<p>Code examples throughout this guide will refer to one or more of the following models:</p>

<p>TIP: All of the following models use <code class="language-plaintext highlighter-rouge">id</code> as the primary key, unless specified otherwise.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="ss">year_published: :desc</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span>
  <span class="n">belongs_to</span> <span class="ss">:author</span>
  <span class="n">has_many</span> <span class="ss">:reviews</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">join_table: </span><span class="s2">"books_orders"</span>

  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:old</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="o">...</span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print_and_expensive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">out_of_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"price &gt; 500"</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:costs_more_than</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"price &gt; ?"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
  <span class="n">has_many</span> <span class="ss">:reviews</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="ss">join_table: </span><span class="s2">"books_orders"</span>

  <span class="n">enum</span> <span class="ss">:status</span><span class="p">,</span> <span class="p">[</span><span class="ss">:shipped</span><span class="p">,</span> <span class="ss">:being_packed</span><span class="p">,</span> <span class="ss">:complete</span><span class="p">,</span> <span class="ss">:cancelled</span><span class="p">]</span>

  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Review</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">belongs_to</span> <span class="ss">:book</span>

  <span class="n">enum</span> <span class="ss">:state</span><span class="p">,</span> <span class="p">[</span><span class="ss">:not_reviewed</span><span class="p">,</span> <span class="ss">:published</span><span class="p">,</span> <span class="ss">:hidden</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span>
  <span class="n">has_many</span> <span class="ss">:authors</span><span class="p">,</span> <span class="ss">through: :books</span>
<span class="k">end</span>
</code></pre></div></div>

<p><img src="images/active_record_querying/bookstore_models.png" alt="Diagram of all of the bookstore models" /></p>

<h2 id="retrieving-objects-from-the-database">Retrieving Objects from the Database</h2>

<p>To retrieve objects from the database, Active Record provides several finder methods. Each finder method allows you to pass arguments into it to perform certain queries on your database without writing raw SQL.</p>

<p>The methods are:</p>

<ul>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-annotate"><code class="language-plaintext highlighter-rouge">annotate</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code class="language-plaintext highlighter-rouge">find</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-create_with"><code class="language-plaintext highlighter-rouge">create_with</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code class="language-plaintext highlighter-rouge">distinct</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code class="language-plaintext highlighter-rouge">eager_load</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-extending"><code class="language-plaintext highlighter-rouge">extending</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-extract_associated"><code class="language-plaintext highlighter-rouge">extract_associated</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-from"><code class="language-plaintext highlighter-rouge">from</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-group"><code class="language-plaintext highlighter-rouge">group</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-having"><code class="language-plaintext highlighter-rouge">having</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code class="language-plaintext highlighter-rouge">includes</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code class="language-plaintext highlighter-rouge">joins</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code class="language-plaintext highlighter-rouge">left_outer_joins</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code class="language-plaintext highlighter-rouge">limit</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-lock"><code class="language-plaintext highlighter-rouge">lock</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-none"><code class="language-plaintext highlighter-rouge">none</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code class="language-plaintext highlighter-rouge">offset</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-optimizer_hints"><code class="language-plaintext highlighter-rouge">optimizer_hints</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-order"><code class="language-plaintext highlighter-rouge">order</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code class="language-plaintext highlighter-rouge">preload</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code class="language-plaintext highlighter-rouge">readonly</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-references"><code class="language-plaintext highlighter-rouge">references</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code class="language-plaintext highlighter-rouge">reorder</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code class="language-plaintext highlighter-rouge">reselect</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-regroup"><code class="language-plaintext highlighter-rouge">regroup</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code class="language-plaintext highlighter-rouge">reverse_order</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select"><code class="language-plaintext highlighter-rouge">select</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code class="language-plaintext highlighter-rouge">where</code></a></li>
</ul>

<p>Finder methods that return a collection, such as <code class="language-plaintext highlighter-rouge">where</code> and <code class="language-plaintext highlighter-rouge">group</code>, return an instance of <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html"><code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code></a>.  Methods that find a single entity, such as <code class="language-plaintext highlighter-rouge">find</code> and <code class="language-plaintext highlighter-rouge">first</code>, return a single instance of the model.</p>

<p>The primary operation of <code class="language-plaintext highlighter-rouge">Model.find(options)</code> can be summarized as:</p>

<ul>
  <li>Convert the supplied options to an equivalent SQL query.</li>
  <li>Fire the SQL query and retrieve the corresponding results from the database.</li>
  <li>Instantiate the equivalent Ruby object of the appropriate model for every resulting row.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">after_find</code> and then <code class="language-plaintext highlighter-rouge">after_initialize</code> callbacks, if any.</li>
</ul>

<h3 id="retrieving-a-single-object">Retrieving a Single Object</h3>

<p>Active Record provides several different ways of retrieving a single object.</p>

<h4 id="find"><code class="language-plaintext highlighter-rouge">find</code></h4>

<p>Using the <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code class="language-plaintext highlighter-rouge">find</code></a> method, you can retrieve the object corresponding to the specified <em>primary key</em> that matches any supplied options. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Find the customer with primary key (id) 10.
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">=&gt; #&lt;Customer id: 10, first_name: "Ryan"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">find</code> method will raise an <code class="language-plaintext highlighter-rouge">ActiveRecord::RecordNotFound</code> exception if no matching record is found.</p>

<p>You can also use this method to query for multiple objects. Call the <code class="language-plaintext highlighter-rouge">find</code> method and pass in an array of primary keys. The return will be an array containing all of the matching records for the supplied <em>primary keys</em>. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Find the customers with primary keys 1 and 10.
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="c1"># OR Customer.find(1, 10)</span>
<span class="gp">=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 10, first_name: "Ryan"&gt;]</span>
</code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
</code></pre></div></div>

<p>WARNING: The <code class="language-plaintext highlighter-rouge">find</code> method will raise an <code class="language-plaintext highlighter-rouge">ActiveRecord::RecordNotFound</code> exception unless a matching record is found for <strong>all</strong> of the supplied primary keys.</p>

<p>If your table uses a composite primary key, you’ll need to pass in an array to find a single item. For instance, if customers were defined with <code class="language-plaintext highlighter-rouge">[:store_id, :id]</code> as a primary key:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Find the customer with store_id 3 and id 17
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">17</span><span class="p">])</span>
<span class="gp">=&gt; #&lt;Customer store_id: 3, id: 17, first_name: "Magda"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">store_id</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">AND</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">17</span>
</code></pre></div></div>

<p>To find multiple customers with composite IDs, you would pass an array of arrays:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Find the customers with primary keys [1, 8] and [7, 15].
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">]])</span> <span class="c1"># OR Customer.find([1, 8], [7, 15])</span>
<span class="gp">=&gt; [#&lt;Customer store_id: 1, id: 8, first_name: "Pat"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer store_id: 7, id: 15, first_name: "Chris"&gt;]</span>
</code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">store_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">8</span> <span class="k">OR</span> <span class="n">store_id</span> <span class="o">=</span> <span class="mi">7</span> <span class="k">AND</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">15</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="take"><code class="language-plaintext highlighter-rouge">take</code></h4>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-take"><code class="language-plaintext highlighter-rouge">take</code></a> method retrieves a record without any implicit ordering. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">take</span>
<span class="gp">=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">take</code> method returns <code class="language-plaintext highlighter-rouge">nil</code> if no record is found and no exception will be raised.</p>

<p>You can pass in a numerical argument to the <code class="language-plaintext highlighter-rouge">take</code> method to return up to that number of results. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 220, first_name: "Sara"&gt;]</span>
</code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">2</span>
</code></pre></div></div>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-take-21"><code class="language-plaintext highlighter-rouge">take!</code></a> method behaves exactly like <code class="language-plaintext highlighter-rouge">take</code>, except that it will raise <code class="language-plaintext highlighter-rouge">ActiveRecord::RecordNotFound</code> if no matching record is found.</p>

<p>TIP: The retrieved record may vary depending on the database engine.</p>

<h4 id="first"><code class="language-plaintext highlighter-rouge">first</code></h4>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-first"><code class="language-plaintext highlighter-rouge">first</code></a> method finds the first record ordered by primary key (default). For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">first</code> method returns <code class="language-plaintext highlighter-rouge">nil</code> if no matching record is found and no exception will be raised.</p>

<p>If your <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contains an order method, <code class="language-plaintext highlighter-rouge">first</code> will return the first record according to this ordering.</p>

<p>You can pass in a numerical argument to the <code class="language-plaintext highlighter-rouge">first</code> method to return up to that number of results. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 2, first_name: "Fifo"&gt;, #&lt;Customer id: 3, first_name: "Filo"&gt;]</span>
</code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre></div></div>

<p>Models with composite primary keys will use the full composite primary key for ordering.
For instance, if customers were defined with <code class="language-plaintext highlighter-rouge">[:store_id, :id]</code> as a primary key:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">=&gt; #&lt;Customer id: 2, store_id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">store_id</span> <span class="k">ASC</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>On a collection that is ordered using <code class="language-plaintext highlighter-rouge">order</code>, <code class="language-plaintext highlighter-rouge">first</code> will return the first record ordered by the specified attribute for <code class="language-plaintext highlighter-rouge">order</code>.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">first</span>
<span class="gp">=&gt; #&lt;Customer id: 2, first_name: "Fifo"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-first-21"><code class="language-plaintext highlighter-rouge">first!</code></a> method behaves exactly like <code class="language-plaintext highlighter-rouge">first</code>, except that it will raise <code class="language-plaintext highlighter-rouge">ActiveRecord::RecordNotFound</code> if no matching record is found.</p>

<h4 id="last"><code class="language-plaintext highlighter-rouge">last</code></h4>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-last"><code class="language-plaintext highlighter-rouge">last</code></a> method finds the last record ordered by primary key (default). For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span>
<span class="gp">=&gt; #&lt;Customer id: 221, first_name: "Russel"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">last</code> method returns <code class="language-plaintext highlighter-rouge">nil</code> if no matching record is found and no exception will be raised.</p>

<p>Models with composite primary keys will use the full composite primary key for ordering.
For instance, if customers were defined with <code class="language-plaintext highlighter-rouge">[:store_id, :id]</code> as a primary key:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span>
<span class="gp">=&gt; #&lt;Customer id: 221, store_id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">store_id</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>If your <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contains an order method, <code class="language-plaintext highlighter-rouge">last</code> will return the last record according to this ordering.</p>

<p>You can pass in a numerical argument to the <code class="language-plaintext highlighter-rouge">last</code> method to return up to that number of results. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">=&gt; [#&lt;Customer id: 219, first_name: "James"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 220, first_name: "Sara"&gt;, #&lt;Customer id: 221, first_name: "Russel"&gt;]</span>
</code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre></div></div>

<p>On a collection that is ordered using <code class="language-plaintext highlighter-rouge">order</code>, <code class="language-plaintext highlighter-rouge">last</code> will return the last record ordered by the specified attribute for <code class="language-plaintext highlighter-rouge">order</code>.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">last</span>
<span class="gp">=&gt; #&lt;Customer id: 220, first_name: "Sara"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-last-21"><code class="language-plaintext highlighter-rouge">last!</code></a> method behaves exactly like <code class="language-plaintext highlighter-rouge">last</code>, except that it will raise <code class="language-plaintext highlighter-rouge">ActiveRecord::RecordNotFound</code> if no matching record is found.</p>

<h4 id="find_by"><code class="language-plaintext highlighter-rouge">find_by</code></h4>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by"><code class="language-plaintext highlighter-rouge">find_by</code></a> method finds the first record matching some conditions. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Lifo'</span>
<span class="gp">=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Jon'</span>
<span class="p">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>It is equivalent to writing:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s2">"Lifo"</span><span class="p">).</span><span class="nf">take</span>
</code></pre></div></div>

<p>The SQL equivalent of the above is:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Lifo'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Note that there is no <code class="language-plaintext highlighter-rouge">ORDER BY</code> in the above SQL.  If your <code class="language-plaintext highlighter-rouge">find_by</code> conditions can match multiple records, you should <a href="#ordering">apply an order</a> to guarantee a deterministic result.</p>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by-21"><code class="language-plaintext highlighter-rouge">find_by!</code></a> method behaves exactly like <code class="language-plaintext highlighter-rouge">find_by</code>, except that it will raise <code class="language-plaintext highlighter-rouge">ActiveRecord::RecordNotFound</code> if no matching record is found. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by!</span> <span class="ss">first_name: </span><span class="s1">'does not exist'</span>
<span class="go">ActiveRecord::RecordNotFound
</span></code></pre></div></div>

<p>This is equivalent to writing:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s2">"does not exist"</span><span class="p">).</span><span class="nf">take!</span>
</code></pre></div></div>

<h5 id="conditions-with-id">Conditions with <code class="language-plaintext highlighter-rouge">:id</code></h5>

<p>When specifying conditions on methods like <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by"><code class="language-plaintext highlighter-rouge">find_by</code></a> and <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code class="language-plaintext highlighter-rouge">where</code></a>, the use of <code class="language-plaintext highlighter-rouge">id</code> will match against
an <code class="language-plaintext highlighter-rouge">:id</code> attribute on the model. This is different from <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code class="language-plaintext highlighter-rouge">find</code></a>, where the ID passed in should be a primary key value.</p>

<p>Take caution when using <code class="language-plaintext highlighter-rouge">find_by(id:)</code> on models where <code class="language-plaintext highlighter-rouge">:id</code> is not the primary key, such as composite primary key models.
For example, if customers were defined with <code class="language-plaintext highlighter-rouge">[:store_id, :id]</code> as a primary key:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span>
<span class="gp">=&gt; #&lt;Customer id: 10, store_id: 5, first_name: "Joe"&gt;</span><span class="w">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">id: </span><span class="n">customer</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span> <span class="c1"># Customer.find_by(id: [5, 10])</span>
<span class="gp">=&gt; #&lt;Customer id: 5, store_id: 3, first_name: "Bob"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>Here, we might intend to search for a single record with the composite primary key <code class="language-plaintext highlighter-rouge">[5, 10]</code>, but Active Record will
search for a record with an <code class="language-plaintext highlighter-rouge">:id</code> column of <em>either</em> 5 or 10, and may return the wrong record.</p>

<p>TIP: The <a href="https://api.rubyonrails.org/classes/ActiveRecord/ModelSchema.html#method-i-id_value"><code class="language-plaintext highlighter-rouge">id_value</code></a> method can be used to fetch the value of the <code class="language-plaintext highlighter-rouge">:id</code> column for a record, for use in finder
methods such as <code class="language-plaintext highlighter-rouge">find_by</code> and <code class="language-plaintext highlighter-rouge">where</code>. See example below:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span>
<span class="gp">=&gt; #&lt;Customer id: 10, store_id: 5, first_name: "Joe"&gt;</span><span class="w">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">id: </span><span class="n">customer</span><span class="p">.</span><span class="nf">id_value</span><span class="p">)</span> <span class="c1"># Customer.find_by(id: 10)</span>
<span class="gp">=&gt; #&lt;Customer id: 10, store_id: 5, first_name: "Joe"&gt;</span><span class="w">
</span></code></pre></div></div>

<h3 id="retrieving-multiple-objects-in-batches">Retrieving Multiple Objects in Batches</h3>

<p>We often need to iterate over a large set of records, as when we send a newsletter to a large set of customers, or when we export data.</p>

<p>This may appear straightforward:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This may consume too much memory if the table is big.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre></div></div>

<p>But this approach becomes increasingly impractical as the table size increases, since <code class="language-plaintext highlighter-rouge">Customer.all.each</code> instructs Active Record to fetch <em>the entire table</em> in a single pass, build a model object per row, and then keep the entire array of model objects in memory. Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.</p>

<p>Rails provides two methods that address this problem by dividing records into memory-friendly batches for processing. The first method, <code class="language-plaintext highlighter-rouge">find_each</code>, retrieves a batch of records and then yields <em>each</em> record to the block individually as a model. The second method, <code class="language-plaintext highlighter-rouge">find_in_batches</code>, retrieves a batch of records and then yields <em>the entire batch</em> to the block as an array of models.</p>

<p>TIP: The <code class="language-plaintext highlighter-rouge">find_each</code> and <code class="language-plaintext highlighter-rouge">find_in_batches</code> methods are intended for use in the batch processing of a large number of records that wouldn’t fit in memory all at once. If you just need to loop over a thousand records the regular find methods are the preferred option.</p>

<h4 id="find_each"><code class="language-plaintext highlighter-rouge">find_each</code></h4>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_each"><code class="language-plaintext highlighter-rouge">find_each</code></a> method retrieves records in batches and then yields <em>each</em> one to the block. In the following example, <code class="language-plaintext highlighter-rouge">find_each</code> retrieves customers in batches of 1000 and yields them to the block one by one:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This process is repeated, fetching more batches as needed, until all of the records have been processed.</p>

<p><code class="language-plaintext highlighter-rouge">find_each</code> works on model classes, as seen above, and also on relations:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">weekly_subscriber: </span><span class="kp">true</span><span class="p">).</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre></div></div>

<p>as long as they have no ordering, since the method needs to force an order
internally to iterate.</p>

<p>If an order is present in the receiver the behavior depends on the flag
<a href="configuring.html#config-active-record-error-on-ignored-order"><code class="language-plaintext highlighter-rouge">config.active_record.error_on_ignored_order</code></a>. If true, <code class="language-plaintext highlighter-rouge">ArgumentError</code> is
raised, otherwise the order is ignored and a warning issued, which is the
default. This can be overridden with the option <code class="language-plaintext highlighter-rouge">:error_on_ignore</code>, explained
below.</p>

<h5 id="options-for-find_each">Options for <code class="language-plaintext highlighter-rouge">find_each</code></h5>

<p><strong><code class="language-plaintext highlighter-rouge">:batch_size</code></strong></p>

<p>The <code class="language-plaintext highlighter-rouge">:batch_size</code> option allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block. For example, to retrieve records in batches of 5000:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">5000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">:start</code></strong></p>

<p>By default, records are fetched in ascending order of the primary key. The <code class="language-plaintext highlighter-rouge">:start</code> option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need. This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.</p>

<p>For example, to send newsletters only to customers with the primary key starting from 2000:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">:finish</code></strong></p>

<p>Similar to the <code class="language-plaintext highlighter-rouge">:start</code> option, <code class="language-plaintext highlighter-rouge">:finish</code> allows you to configure the last ID of the sequence whenever the highest ID is not the one you need.
This would be useful, for example, if you wanted to run a batch process using a subset of records based on <code class="language-plaintext highlighter-rouge">:start</code> and <code class="language-plaintext highlighter-rouge">:finish</code>.</p>

<p>For example, to send newsletters only to customers with the primary key starting from 2000 up to 10000:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">,</span> <span class="ss">finish: </span><span class="mi">10000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Another example would be if you wanted multiple workers handling the same
processing queue. You could have each worker handle 10000 records by setting the
appropriate <code class="language-plaintext highlighter-rouge">:start</code> and <code class="language-plaintext highlighter-rouge">:finish</code> options on each worker.</p>

<p><strong><code class="language-plaintext highlighter-rouge">:error_on_ignore</code></strong></p>

<p>Overrides the application config to specify if an error should be raised when an
order is present in the relation.</p>

<p><strong><code class="language-plaintext highlighter-rouge">:order</code></strong></p>

<p>Specifies the primary key order (can be <code class="language-plaintext highlighter-rouge">:asc</code> or <code class="language-plaintext highlighter-rouge">:desc</code>). Defaults to <code class="language-plaintext highlighter-rouge">:asc</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">order: :desc</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="find_in_batches"><code class="language-plaintext highlighter-rouge">find_in_batches</code></h4>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_in_batches"><code class="language-plaintext highlighter-rouge">find_in_batches</code></a> method is similar to <code class="language-plaintext highlighter-rouge">find_each</code>, since both retrieve batches of records. The difference is that <code class="language-plaintext highlighter-rouge">find_in_batches</code> yields <em>batches</em> to the block as an array of models, instead of individually. The following example will yield to the supplied block an array of up to 1000 customers at a time, with the final block containing any remaining customers:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Give add_customers an array of 1000 customers at a time.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">find_in_batches</code> works on model classes, as seen above, and also on relations:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Give add_customers an array of 1000 recently active customers at a time.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">recently_active</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>as long as they have no ordering, since the method needs to force an order
internally to iterate.</p>

<h5 id="options-for-find_in_batches">Options for <code class="language-plaintext highlighter-rouge">find_in_batches</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">find_in_batches</code> method accepts the same options as <code class="language-plaintext highlighter-rouge">find_each</code>:</p>

<p><strong><code class="language-plaintext highlighter-rouge">:batch_size</code></strong></p>

<p>Just like for <code class="language-plaintext highlighter-rouge">find_each</code>, <code class="language-plaintext highlighter-rouge">batch_size</code> establishes how many records will be retrieved in each group. For example, retrieving batches of 2500 records can be specified as:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">2500</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">:start</code></strong></p>

<p>The <code class="language-plaintext highlighter-rouge">start</code> option allows specifying the beginning ID from where records will be selected. As mentioned before, by default records are fetched in ascending order of the primary key. For example, to retrieve customers starting on ID: 5000 in batches of 2500 records, the following code can be used:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">2500</span><span class="p">,</span> <span class="ss">start: </span><span class="mi">5000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">:finish</code></strong></p>

<p>The <code class="language-plaintext highlighter-rouge">finish</code> option allows specifying the ending ID of the records to be retrieved. The code below shows the case of retrieving customers in batches, up to the customer with ID: 7000:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">finish: </span><span class="mi">7000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">:error_on_ignore</code></strong></p>

<p>The <code class="language-plaintext highlighter-rouge">error_on_ignore</code> option overrides the application config to specify if an error should be raised when a specific order is present in the relation.</p>

<h2 id="conditions">Conditions</h2>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code class="language-plaintext highlighter-rouge">where</code></a> method allows you to specify conditions to limit the records returned, representing the <code class="language-plaintext highlighter-rouge">WHERE</code>-part of the SQL statement. Conditions can either be specified as a string, array, or hash.</p>

<h3 id="pure-string-conditions">Pure String Conditions</h3>

<p>If you’d like to add conditions to your find, you could just specify them in there, just like <code class="language-plaintext highlighter-rouge">Book.where("title = 'Introduction to Algorithms'")</code>. This will find all books where the <code class="language-plaintext highlighter-rouge">title</code> field value is ‘Introduction to Algorithms’.</p>

<p>WARNING: Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. For example, <code class="language-plaintext highlighter-rouge">Book.where("title LIKE '%#{params[:title]}%'")</code> is not safe. See the next section for the preferred way to handle conditions using an array.</p>

<h3 id="array-conditions">Array Conditions</h3>

<p>Now what if that title could vary, say as an argument from somewhere? The find would then take the form:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span>
</code></pre></div></div>

<p>Active Record will take the first argument as the conditions string and any additional arguments will replace the question marks <code class="language-plaintext highlighter-rouge">(?)</code> in it.</p>

<p>If you want to specify multiple conditions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ? AND out_of_print = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">],</span> <span class="kp">false</span><span class="p">)</span>
</code></pre></div></div>

<p>In this example, the first question mark will be replaced with the value in <code class="language-plaintext highlighter-rouge">params[:title]</code> and the second will be replaced with the SQL representation of <code class="language-plaintext highlighter-rouge">false</code>, which depends on the adapter.</p>

<p>This code is highly preferable:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span>
</code></pre></div></div>

<p>to this code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div></div>

<p>because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database <strong>as-is</strong>. This means that it will be an unescaped variable directly from a user who may have malicious intent. If you do this, you put your entire database at risk because once a user finds out they can exploit your database they can do just about anything to it. Never ever put your arguments directly inside the conditions string.</p>

<p>TIP: For more information on the dangers of SQL injection, see the <a href="security.html#sql-injection">Ruby on Rails Security Guide</a>.</p>

<h4 id="placeholder-conditions">Placeholder Conditions</h4>

<p>Similar to the <code class="language-plaintext highlighter-rouge">(?)</code> replacement style of params, you can also specify keys in your conditions string along with a corresponding keys/values hash:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= :start_date AND created_at &lt;= :end_date"</span><span class="p">,</span>
  <span class="p">{</span> <span class="ss">start_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:start_date</span><span class="p">],</span> <span class="ss">end_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:end_date</span><span class="p">]</span> <span class="p">})</span>
</code></pre></div></div>

<p>This makes for clearer readability if you have a large number of variable conditions.</p>

<h4 id="conditions-that-use-like">Conditions That Use <code class="language-plaintext highlighter-rouge">LIKE</code></h4>

<p>Although condition arguments are automatically escaped to prevent SQL injection, SQL <code class="language-plaintext highlighter-rouge">LIKE</code> wildcards (i.e., <code class="language-plaintext highlighter-rouge">%</code> and <code class="language-plaintext highlighter-rouge">_</code>) are <strong>not</strong> escaped. This may cause unexpected behavior if an unsanitized value is used in an argument. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title LIKE ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">]</span> <span class="o">+</span> <span class="s2">"%"</span><span class="p">)</span>
</code></pre></div></div>

<p>In the above code, the intent is to match titles that start with a user-specified string. However, any occurrences of <code class="language-plaintext highlighter-rouge">%</code> or <code class="language-plaintext highlighter-rouge">_</code> in <code class="language-plaintext highlighter-rouge">params[:title]</code> will be treated as wildcards, leading to surprising query results. In some circumstances, this may also prevent the database from using an intended index, leading to a much slower query.</p>

<p>To avoid these problems, use <a href="https://api.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_like"><code class="language-plaintext highlighter-rouge">sanitize_sql_like</code></a> to escape wildcard characters in the relevant portion of the argument:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title LIKE ?"</span><span class="p">,</span>
  <span class="no">Book</span><span class="p">.</span><span class="nf">sanitize_sql_like</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span> <span class="o">+</span> <span class="s2">"%"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="hash-conditions">Hash Conditions</h3>

<p>Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want qualified and the values of how you want to qualify them:</p>

<p>NOTE: Only equality, range, and subset checking are possible with Hash conditions.</p>

<h4 id="equality-conditions">Equality Conditions</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>This will generate SQL like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>The field name can also be a string:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"out_of_print"</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">author</span> <span class="o">=</span> <span class="no">Author</span><span class="p">.</span><span class="nf">first</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">author: </span><span class="n">author</span><span class="p">)</span>
<span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">books: </span><span class="p">{</span> <span class="ss">author: </span><span class="n">author</span> <span class="p">})</span>
</code></pre></div></div>

<p>Hash conditions may also be specified in a tuple-like syntax, where the key is an array of columns and the value is
an array of tuples:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">([</span><span class="ss">:author_id</span><span class="p">,</span> <span class="ss">:id</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</code></pre></div></div>

<p>This syntax can be useful for querying relations where the table uses a composite primary key:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:author_id</span><span class="p">,</span> <span class="ss">:id</span><span class="p">]</span>
<span class="k">end</span>

<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="no">Book</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=&gt;</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</code></pre></div></div>

<h4 id="range-conditions">Range Conditions</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span><span class="p">)</span>
</code></pre></div></div>

<p>This will find all books created yesterday by using a <code class="language-plaintext highlighter-rouge">BETWEEN</code> SQL statement:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">BETWEEN</span> <span class="s1">'2008-12-21 00:00:00'</span> <span class="k">AND</span> <span class="s1">'2008-12-22 00:00:00'</span><span class="p">)</span>
</code></pre></div></div>

<p>This demonstrates a shorter syntax for the examples in <a href="#array-conditions">Array Conditions</a></p>

<p>Beginless and endless ranges are supported and can be used to build less/greater than conditions.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="p">)</span>
</code></pre></div></div>

<p>This would generate SQL like:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="o">&gt;=</span> <span class="s1">'2008-12-21 00:00:00'</span>
</code></pre></div></div>

<h4 id="subset-conditions">Subset Conditions</h4>

<p>If you want to find records using the <code class="language-plaintext highlighter-rouge">IN</code> expression you can pass an array to the conditions hash:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div></div>

<p>This code will generate SQL like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="not-conditions">NOT Conditions</h3>

<p><code class="language-plaintext highlighter-rouge">NOT</code> SQL queries can be built by <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods/WhereChain.html#method-i-not"><code class="language-plaintext highlighter-rouge">where.not</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div></div>

<p>In other words, this query can be generated by calling <code class="language-plaintext highlighter-rouge">where</code> with no argument, then immediately chain with <code class="language-plaintext highlighter-rouge">not</code> passing <code class="language-plaintext highlighter-rouge">where</code> conditions.  This will generate SQL like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>

<p>If a query has a hash condition with non-nil values on a nullable column, the records that have <code class="language-plaintext highlighter-rouge">nil</code> values on the nullable column won’t be returned. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="kp">nil</span><span class="p">)</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="s2">"UK"</span><span class="p">)</span>
<span class="c1"># =&gt; []</span>

<span class="c1"># But</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="s2">"UK"</span><span class="p">)</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="kp">nil</span><span class="p">)</span>
<span class="c1"># =&gt; [#&lt;Customer id: 2, nullable_country: "UK"&gt;]</span>
</code></pre></div></div>

<h3 id="or-conditions">OR Conditions</h3>

<p><code class="language-plaintext highlighter-rouge">OR</code> conditions between two relations can be built by calling <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-or"><code class="language-plaintext highlighter-rouge">or</code></a> on the first
relation, and passing the second one as an argument.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">last_name: </span><span class="s2">"Smith"</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span> <span class="k">OR</span> <span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="and-conditions">AND Conditions</h3>

<p><code class="language-plaintext highlighter-rouge">AND</code> conditions can be built by chaining <code class="language-plaintext highlighter-rouge">where</code> conditions.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">last_name: </span><span class="s2">"Smith"</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span> <span class="k">AND</span> <span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">AND</code> conditions for the logical intersection between relations can be built by
calling <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-and"><code class="language-plaintext highlighter-rouge">and</code></a> on the first relation, and passing the second one as an
argument.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]).</span><span class="nf">and</span><span class="p">(</span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">AND</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="ordering">Ordering</h2>

<p>To retrieve records from the database in a specific order, you can use the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-order"><code class="language-plaintext highlighter-rouge">order</code></a> method.</p>

<p>For example, if you’re getting a set of records and want to order them in ascending order by the <code class="language-plaintext highlighter-rouge">created_at</code> field in your table:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
</code></pre></div></div>

<p>You could specify <code class="language-plaintext highlighter-rouge">ASC</code> or <code class="language-plaintext highlighter-rouge">DESC</code> as well:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :asc</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at ASC"</span><span class="p">)</span>
</code></pre></div></div>

<p>Or ordering by multiple fields:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">title: :asc</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC, created_at DESC"</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC"</span><span class="p">,</span> <span class="s2">"created_at DESC"</span><span class="p">)</span>
</code></pre></div></div>

<p>If you want to call <code class="language-plaintext highlighter-rouge">order</code> multiple times, subsequent orders will be appended to the first:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="go">SELECT * FROM books ORDER BY title ASC, created_at DESC
</span></code></pre></div></div>

<p>You can also order from a joined table</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">books: </span><span class="p">{</span> <span class="ss">print_year: :desc</span> <span class="p">},</span> <span class="ss">authors: </span><span class="p">{</span> <span class="ss">name: :asc</span> <span class="p">})</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"books.print_year desc"</span><span class="p">,</span> <span class="s2">"authors.name asc"</span><span class="p">)</span>
</code></pre></div></div>

<p>WARNING: In most database systems, on selecting fields with <code class="language-plaintext highlighter-rouge">distinct</code> from a result set using methods like <code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">pluck</code> and <code class="language-plaintext highlighter-rouge">ids</code>; the <code class="language-plaintext highlighter-rouge">order</code> method will raise an <code class="language-plaintext highlighter-rouge">ActiveRecord::StatementInvalid</code> exception unless the field(s) used in <code class="language-plaintext highlighter-rouge">order</code> clause are included in the select list. See the next section for selecting fields from the result set.</p>

<h2 id="selecting-specific-fields">Selecting Specific Fields</h2>

<p>By default, <code class="language-plaintext highlighter-rouge">Model.find</code> selects all the fields from the result set using <code class="language-plaintext highlighter-rouge">select *</code>.</p>

<p>To select only a subset of fields from the result set, you can specify the subset via the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select"><code class="language-plaintext highlighter-rouge">select</code></a> method.</p>

<p>For example, to select only <code class="language-plaintext highlighter-rouge">isbn</code> and <code class="language-plaintext highlighter-rouge">out_of_print</code> columns:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:isbn</span><span class="p">,</span> <span class="ss">:out_of_print</span><span class="p">)</span>
<span class="c1"># OR</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"isbn, out_of_print"</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL query used by this find call will be somewhat like:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">isbn</span><span class="p">,</span> <span class="n">out_of_print</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre></div></div>

<p>Be careful because this also means you’re initializing a model object with only the fields that you’ve selected. If you attempt to access a field that is not in the initialized record you’ll receive:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ActiveModel::MissingAttributeError: missing attribute '&lt;attribute&gt;' for Book
</code></pre></div></div>

<p>Where <code class="language-plaintext highlighter-rouge">&lt;attribute&gt;</code> is the attribute you asked for. The <code class="language-plaintext highlighter-rouge">id</code> method will not raise the <code class="language-plaintext highlighter-rouge">ActiveRecord::MissingAttributeError</code>, so just be careful when working with associations because they need the <code class="language-plaintext highlighter-rouge">id</code> method to function properly.</p>

<p>If you would like to only grab a single record per unique value in a certain field, you can use <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code class="language-plaintext highlighter-rouge">distinct</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:last_name</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre></div></div>

<p>This would generate SQL like:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">last_name</span> <span class="k">FROM</span> <span class="n">customers</span>
</code></pre></div></div>

<p>You can also remove the uniqueness constraint:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Returns unique last_names</span>
<span class="n">query</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:last_name</span><span class="p">).</span><span class="nf">distinct</span>

<span class="c1"># Returns all last_names, even if there are duplicates</span>
<span class="n">query</span><span class="p">.</span><span class="nf">distinct</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="limit-and-offset">Limit and Offset</h2>

<p>To apply <code class="language-plaintext highlighter-rouge">LIMIT</code> to the SQL fired by the <code class="language-plaintext highlighter-rouge">Model.find</code>, you can specify the <code class="language-plaintext highlighter-rouge">LIMIT</code> using <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code class="language-plaintext highlighter-rouge">limit</code></a> and <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code class="language-plaintext highlighter-rouge">offset</code></a> methods on the relation.</p>

<p>You can use <code class="language-plaintext highlighter-rouge">limit</code> to specify the number of records to be retrieved, and use <code class="language-plaintext highlighter-rouge">offset</code> to specify the number of records to skip before starting to return the records. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>will return a maximum of 5 customers and because it specifies no offset it will return the first 5 in the table. The SQL it executes looks like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">5</span>
</code></pre></div></div>

<p>Adding <code class="language-plaintext highlighter-rouge">offset</code> to that</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
</code></pre></div></div>

<p>will return instead a maximum of 5 customers beginning with the 31st. The SQL looks like:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">5</span> <span class="k">OFFSET</span> <span class="mi">30</span>
</code></pre></div></div>

<h2 id="grouping">Grouping</h2>

<p>To apply a <code class="language-plaintext highlighter-rouge">GROUP BY</code> clause to the SQL fired by the finder, you can use the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-group"><code class="language-plaintext highlighter-rouge">group</code></a> method.</p>

<p>For example, if you want to find a collection of the dates on which orders were created:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
</code></pre></div></div>

<p>And this will give you a single <code class="language-plaintext highlighter-rouge">Order</code> object for each date where there are orders in the database.</p>

<p>The SQL that would be executed would be something like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">created_at</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">created_at</span>
</code></pre></div></div>

<h3 id="total-of-grouped-items">Total of Grouped Items</h3>

<p>To get the total of grouped items on a single query, call <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-count"><code class="language-plaintext highlighter-rouge">count</code></a> after the <code class="language-plaintext highlighter-rouge">group</code>.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:status</span><span class="p">).</span><span class="nf">count</span>
<span class="p">=&gt;</span> <span class="p">{</span><span class="s2">"being_packed"</span><span class="o">=&gt;</span><span class="mi">7</span><span class="p">,</span> <span class="s2">"shipped"</span><span class="o">=&gt;</span><span class="mi">12</span><span class="p">}</span>
</code></pre></div></div>

<p>The SQL that would be executed would be something like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">count_all</span><span class="p">,</span> <span class="n">status</span> <span class="k">AS</span> <span class="n">status</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">status</span>
</code></pre></div></div>

<h3 id="having-conditions">HAVING Conditions</h3>

<p>SQL uses the <code class="language-plaintext highlighter-rouge">HAVING</code> clause to specify conditions on the <code class="language-plaintext highlighter-rouge">GROUP BY</code> fields. You can add the <code class="language-plaintext highlighter-rouge">HAVING</code> clause to the SQL fired by the <code class="language-plaintext highlighter-rouge">Model.find</code> by adding the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-having"><code class="language-plaintext highlighter-rouge">having</code></a> method to the find.</p>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at as ordered_date, sum(total) as total_price"</span><span class="p">).</span>
  <span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"sum(total) &gt; ?"</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL that would be executed would be something like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">created_at</span> <span class="k">as</span> <span class="n">ordered_date</span><span class="p">,</span> <span class="k">sum</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="k">as</span> <span class="n">total_price</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">created_at</span>
<span class="k">HAVING</span> <span class="k">sum</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">200</span>
</code></pre></div></div>

<p>This returns the date and total price for each order object, grouped by the day they were ordered and where the total is more than $200.</p>

<p>You would access the <code class="language-plaintext highlighter-rouge">total_price</code> for each order object returned like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">big_orders</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at, sum(total) as total_price"</span><span class="p">)</span>
                  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
                  <span class="p">.</span><span class="nf">having</span><span class="p">(</span><span class="s2">"sum(total) &gt; ?"</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="n">big_orders</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">total_price</span>
<span class="c1"># Returns the total price for the first Order object</span>
</code></pre></div></div>

<h2 id="overriding-conditions">Overriding Conditions</h2>

<h3 id="unscope"><code class="language-plaintext highlighter-rouge">unscope</code></h3>

<p>You can specify certain conditions to be removed using the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-unscope"><code class="language-plaintext highlighter-rouge">unscope</code></a> method. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"id &gt; 100"</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"id desc"</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="k">LIMIT</span> <span class="mi">20</span>

<span class="c1">-- Original query without `unscope`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">desc</span> <span class="k">LIMIT</span> <span class="mi">20</span>
</code></pre></div></div>

<p>You can also unscope specific <code class="language-plaintext highlighter-rouge">where</code> clauses. For example, this will remove <code class="language-plaintext highlighter-rouge">id</code> condition from the where clause:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">10</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">where: :id</span><span class="p">)</span>
<span class="c1"># SELECT books.* FROM books WHERE out_of_print = 0</span>
</code></pre></div></div>

<p>A relation which has used <code class="language-plaintext highlighter-rouge">unscope</code> will affect any relation into which it is merged:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"id desc"</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Book</span><span class="p">.</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">))</span>
<span class="c1"># SELECT books.* FROM books</span>
</code></pre></div></div>

<h3 id="only"><code class="language-plaintext highlighter-rouge">only</code></h3>

<p>You can also override conditions using the <a href="https://api.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-only"><code class="language-plaintext highlighter-rouge">only</code></a> method. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"id &gt; 10"</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"id desc"</span><span class="p">).</span><span class="nf">only</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="ss">:where</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span>

<span class="c1">-- Original query without `only`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">20</span>
</code></pre></div></div>

<h3 id="reselect"><code class="language-plaintext highlighter-rouge">reselect</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code class="language-plaintext highlighter-rouge">reselect</code></a> method overrides an existing select statement. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:isbn</span><span class="p">).</span><span class="nf">reselect</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre></div></div>

<p>Compare this to the case where the <code class="language-plaintext highlighter-rouge">reselect</code> clause is not used:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:isbn</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL executed would be:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">isbn</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre></div></div>

<h3 id="reorder"><code class="language-plaintext highlighter-rouge">reorder</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code class="language-plaintext highlighter-rouge">reorder</code></a> method overrides the default scope order. For example, if the class definition includes this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="ss">year_published: :desc</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And you execute this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">books</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">DESC</span>
</code></pre></div></div>

<p>You can using the <code class="language-plaintext highlighter-rouge">reorder</code> clause to specify a different way to order the books:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">books</span><span class="p">.</span><span class="nf">reorder</span><span class="p">(</span><span class="s2">"year_published ASC"</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">ASC</span>
</code></pre></div></div>

<h3 id="reverse_order"><code class="language-plaintext highlighter-rouge">reverse_order</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code class="language-plaintext highlighter-rouge">reverse_order</code></a> method reverses the ordering clause if specified.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"author_id &gt; 10"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:year_published</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">DESC</span>
</code></pre></div></div>

<p>If no ordering clause is specified in the query, the <code class="language-plaintext highlighter-rouge">reverse_order</code> orders by the primary key in reverse order.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"author_id &gt; 10"</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">reverse_order</code> method accepts <strong>no</strong> arguments.</p>

<h3 id="rewhere"><code class="language-plaintext highlighter-rouge">rewhere</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-rewhere"><code class="language-plaintext highlighter-rouge">rewhere</code></a> method overrides an existing, named <code class="language-plaintext highlighter-rouge">where</code> condition. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">rewhere</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>If the <code class="language-plaintext highlighter-rouge">rewhere</code> clause is not used, the where clauses are ANDed together:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL executed would be:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<h3 id="regroup"><code class="language-plaintext highlighter-rouge">regroup</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-regroup"><code class="language-plaintext highlighter-rouge">regroup</code></a> method overrides an existing, named <code class="language-plaintext highlighter-rouge">group</code> condition. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">regroup</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL that would be executed:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">id</span>
</code></pre></div></div>

<p>If the <code class="language-plaintext highlighter-rouge">regroup</code> clause is not used, the group clauses are combined together:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre></div></div>

<p>The SQL executed would be:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">author</span><span class="p">,</span> <span class="n">id</span>
</code></pre></div></div>

<h2 id="null-relation">Null Relation</h2>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-none"><code class="language-plaintext highlighter-rouge">none</code></a> method returns a chainable relation with no records. Any subsequent conditions chained to the returned relation will continue generating empty relations. This is useful in scenarios where you need a chainable response to a method or a scope that could return zero results.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># returns an empty Relation and fires no queries.</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The highlighted_reviews method below is expected to always return a Relation.</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">highlighted_reviews</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
<span class="c1"># =&gt; Returns average rating of a book</span>

<span class="k">class</span> <span class="nc">Book</span>
  <span class="c1"># Returns reviews if there are at least 5,</span>
  <span class="c1"># else consider this as non-reviewed book</span>
  <span class="k">def</span> <span class="nf">highlighted_reviews</span>
    <span class="k">if</span> <span class="n">reviews</span><span class="p">.</span><span class="nf">count</span> <span class="o">&gt;=</span> <span class="mi">5</span>
      <span class="n">reviews</span>
    <span class="k">else</span>
      <span class="no">Review</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># Does not meet minimum threshold yet</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="readonly-objects">Readonly Objects</h2>

<p>Active Record provides the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code class="language-plaintext highlighter-rouge">readonly</code></a> method on a relation to explicitly disallow modification of any of the returned objects. Any attempt to alter a readonly record will not succeed, raising an <code class="language-plaintext highlighter-rouge">ActiveRecord::ReadOnlyRecord</code> exception.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">readonly</span><span class="p">.</span><span class="nf">first</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">visits</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">save</span> <span class="c1"># Raises an ActiveRecord::ReadOnlyRecord</span>
</code></pre></div></div>

<p>As <code class="language-plaintext highlighter-rouge">customer</code> is explicitly set to be a readonly object, the above code will raise an <code class="language-plaintext highlighter-rouge">ActiveRecord::ReadOnlyRecord</code> exception when calling <code class="language-plaintext highlighter-rouge">customer.save</code> with an updated value of <em>visits</em>.</p>

<h2 id="locking-records-for-update">Locking Records for Update</h2>

<p>Locking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.</p>

<p>Active Record provides two locking mechanisms:</p>

<ul>
  <li>Optimistic Locking</li>
  <li>Pessimistic Locking</li>
</ul>

<h3 id="optimistic-locking">Optimistic Locking</h3>

<p>Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. It does this by checking whether another process has made changes to a record since it was opened. An <code class="language-plaintext highlighter-rouge">ActiveRecord::StaleObjectError</code> exception is thrown if that has occurred and the update is ignored.</p>

<p><strong>Optimistic locking column</strong></p>

<p>In order to use optimistic locking, the table needs to have a column called <code class="language-plaintext highlighter-rouge">lock_version</code> of type integer. Each time the record is updated, Active Record increments the <code class="language-plaintext highlighter-rouge">lock_version</code> column. If an update request is made with a lower value in the <code class="language-plaintext highlighter-rouge">lock_version</code> field than is currently in the <code class="language-plaintext highlighter-rouge">lock_version</code> column in the database, the update request will fail with an <code class="language-plaintext highlighter-rouge">ActiveRecord::StaleObjectError</code>.</p>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">c1</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s2">"Sandra"</span>
<span class="n">c1</span><span class="p">.</span><span class="nf">save</span>

<span class="n">c2</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s2">"Michael"</span>
<span class="n">c2</span><span class="p">.</span><span class="nf">save</span> <span class="c1"># Raises an ActiveRecord::StaleObjectError</span>
</code></pre></div></div>

<p>You’re then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.</p>

<p>This behavior can be turned off by setting <code class="language-plaintext highlighter-rouge">ActiveRecord::Base.lock_optimistically = false</code>.</p>

<p>To override the name of the <code class="language-plaintext highlighter-rouge">lock_version</code> column, <code class="language-plaintext highlighter-rouge">ActiveRecord::Base</code> provides a class attribute called <code class="language-plaintext highlighter-rouge">locking_column</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">locking_column</span> <span class="o">=</span> <span class="ss">:lock_customer_column</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="pessimistic-locking">Pessimistic Locking</h3>

<p>Pessimistic locking uses a locking mechanism provided by the underlying database. Using <code class="language-plaintext highlighter-rouge">lock</code> when building a relation obtains an exclusive lock on the selected rows. Relations using <code class="language-plaintext highlighter-rouge">lock</code> are usually wrapped inside a transaction for preventing deadlock conditions.</p>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Algorithms, second edition"</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">save!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The above session produces the following SQL for a MySQL backend:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="n">ms</span><span class="p">)</span>   <span class="k">BEGIN</span>
<span class="n">Book</span> <span class="k">Load</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">ms</span><span class="p">)</span>   <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">FOR</span> <span class="k">UPDATE</span>
<span class="n">Book</span> <span class="k">Update</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="n">ms</span><span class="p">)</span>   <span class="k">UPDATE</span> <span class="n">books</span> <span class="k">SET</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="s1">'2009-02-07 18:05:56'</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">'Algorithms, second edition'</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="n">ms</span><span class="p">)</span>   <span class="k">COMMIT</span>
</code></pre></div></div>

<p>You can also pass raw SQL to the <code class="language-plaintext highlighter-rouge">lock</code> method for allowing different types of locks. For example, MySQL has an expression called <code class="language-plaintext highlighter-rouge">LOCK IN SHARE MODE</code> where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">lock</span><span class="p">(</span><span class="s2">"LOCK IN SHARE MODE"</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>NOTE:  Note that your database must support the raw SQL, that you pass in to the <code class="language-plaintext highlighter-rouge">lock</code> method.</p>

<p>If you already have an instance of your model, you can start a transaction and acquire the lock in one go using the following code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">first</span>
<span class="n">book</span><span class="p">.</span><span class="nf">with_lock</span> <span class="k">do</span>
  <span class="c1"># This block is called within a transaction,</span>
  <span class="c1"># book is already locked.</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="joining-tables">Joining Tables</h2>

<p>Active Record provides two finder methods for specifying <code class="language-plaintext highlighter-rouge">JOIN</code> clauses on the
resulting SQL: <code class="language-plaintext highlighter-rouge">joins</code> and <code class="language-plaintext highlighter-rouge">left_outer_joins</code>.
While <code class="language-plaintext highlighter-rouge">joins</code> should be used for <code class="language-plaintext highlighter-rouge">INNER JOIN</code> or custom queries,
<code class="language-plaintext highlighter-rouge">left_outer_joins</code> is used for queries using <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code>.</p>

<h3 id="joins"><code class="language-plaintext highlighter-rouge">joins</code></h3>

<p>There are multiple ways to use the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code class="language-plaintext highlighter-rouge">joins</code></a> method.</p>

<h4 id="using-a-string-sql-fragment">Using a String SQL Fragment</h4>

<p>You can just supply the raw SQL specifying the <code class="language-plaintext highlighter-rouge">JOIN</code> clause to <code class="language-plaintext highlighter-rouge">joins</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="s2">"INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE"</span><span class="p">)</span>
</code></pre></div></div>

<p>This will result in the following SQL:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="k">FALSE</span>
</code></pre></div></div>

<h4 id="using-arrayhash-of-named-associations">Using Array/Hash of Named Associations</h4>

<p>Active Record lets you use the names of the <a href="association_basics.html">associations</a> defined on the model as a shortcut for specifying <code class="language-plaintext highlighter-rouge">JOIN</code> clauses for those associations when using the <code class="language-plaintext highlighter-rouge">joins</code> method.</p>

<p>All of the following will produce the expected join queries using <code class="language-plaintext highlighter-rouge">INNER JOIN</code>:</p>

<h5 id="joining-a-single-association">Joining a Single Association</h5>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
</code></pre></div></div>

<p>This produces:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
</code></pre></div></div>

<p>Or, in English: “return a Book object for all books with reviews”. Note that you will see duplicate books if a book has more than one review.  If you want unique books, you can use <code class="language-plaintext highlighter-rouge">Book.joins(:reviews).distinct</code>.</p>

<h4 id="joining-multiple-associations">Joining Multiple Associations</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:author</span><span class="p">,</span> <span class="ss">:reviews</span><span class="p">)</span>
</code></pre></div></div>

<p>This produces:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">authors</span> <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
</code></pre></div></div>

<p>Or, in English: “return all books that have an author and at least one review”. Note again that books with multiple reviews will show up multiple times.</p>

<h5 id="joining-nested-associations-single-level">Joining Nested Associations (Single Level)</h5>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">reviews: :customer</span><span class="p">)</span>
</code></pre></div></div>

<p>This produces:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customers</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span>
</code></pre></div></div>

<p>Or, in English: “return all books that have a review by a customer.”</p>

<h5 id="joining-nested-associations-multiple-level">Joining Nested Associations (Multiple Level)</h5>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">books: </span><span class="p">[{</span> <span class="ss">reviews: </span><span class="p">{</span> <span class="ss">customer: :orders</span> <span class="p">}</span> <span class="p">},</span> <span class="ss">:supplier</span><span class="p">])</span>
</code></pre></div></div>

<p>This produces:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customers</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">suppliers</span> <span class="k">ON</span> <span class="n">suppliers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">supplier_id</span>
</code></pre></div></div>

<p>Or, in English: “return all authors that have books with reviews <em>and</em> have been ordered by a customer, and the suppliers for those books.”</p>

<h4 id="specifying-conditions-on-the-joined-tables">Specifying Conditions on the Joined Tables</h4>

<p>You can specify conditions on the joined tables using the regular <a href="#array-conditions">Array</a> and <a href="#pure-string-conditions">String</a> conditions. <a href="#hash-conditions">Hash conditions</a> provide a special syntax for specifying conditions for the joined tables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s2">"orders.created_at"</span> <span class="o">=&gt;</span> <span class="n">time_range</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre></div></div>

<p>This will find all customers who have orders that were created yesterday, using a <code class="language-plaintext highlighter-rouge">BETWEEN</code> SQL expression to compare <code class="language-plaintext highlighter-rouge">created_at</code>.</p>

<p>An alternative and cleaner syntax is to nest the hash conditions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders: </span><span class="p">{</span> <span class="ss">created_at: </span><span class="n">time_range</span> <span class="p">}).</span><span class="nf">distinct</span>
</code></pre></div></div>

<p>For more advanced conditions or to reuse an existing named scope, <a href="https://api.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code class="language-plaintext highlighter-rouge">merge</code></a> may be used. First, let’s add a new named scope to the <code class="language-plaintext highlighter-rouge">Order</code> model:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>

  <span class="n">scope</span> <span class="ss">:created_in_time_range</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="n">time_range</span><span class="p">)</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now we can use <code class="language-plaintext highlighter-rouge">merge</code> to merge in the <code class="language-plaintext highlighter-rouge">created_in_time_range</code> scope:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Order</span><span class="p">.</span><span class="nf">created_in_time_range</span><span class="p">(</span><span class="n">time_range</span><span class="p">)).</span><span class="nf">distinct</span>
</code></pre></div></div>

<p>This will find all customers who have orders that were created yesterday, again using a <code class="language-plaintext highlighter-rouge">BETWEEN</code> SQL expression.</p>

<h3 id="left_outer_joins"><code class="language-plaintext highlighter-rouge">left_outer_joins</code></h3>

<p>If you want to select a set of records whether or not they have associated
records you can use the <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code class="language-plaintext highlighter-rouge">left_outer_joins</code></a> method.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">left_outer_joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">).</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"customers.*, COUNT(reviews.*) AS reviews_count"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"customers.id"</span><span class="p">)</span>
</code></pre></div></div>

<p>Which produces:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">customers</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">reviews</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">reviews_count</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
</code></pre></div></div>

<p>Which means: “return all customers with their count of reviews, whether or not they
have any reviews at all”</p>

<h3 id="whereassociated-and-wheremissing"><code class="language-plaintext highlighter-rouge">where.associated</code> and <code class="language-plaintext highlighter-rouge">where.missing</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">associated</code> and <code class="language-plaintext highlighter-rouge">missing</code> query methods let you select a set of records
based on the presence or absence of an association.</p>

<p>To use <code class="language-plaintext highlighter-rouge">where.associated</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">associated</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
</code></pre></div></div>

<p>Produces:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">reviews</span><span class="p">.</span><span class="n">id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>
</code></pre></div></div>

<p>Which means “return all customers that have made at least one review”.</p>

<p>To use <code class="language-plaintext highlighter-rouge">where.missing</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">missing</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
</code></pre></div></div>

<p>Produces:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">reviews</span><span class="p">.</span><span class="n">id</span> <span class="k">IS</span> <span class="k">NULL</span>
</code></pre></div></div>

<p>Which means “return all customers that have not made any reviews”.</p>

<h2 id="eager-loading-associations">Eager Loading Associations</h2>

<p>Eager loading is the mechanism for loading the associated records of the objects returned by <code class="language-plaintext highlighter-rouge">Model.find</code> using as few queries as possible.</p>

<h3 id="n--1-queries-problem">N + 1 Queries Problem</h3>

<p>Consider the following code, which finds 10 books and prints their authors’ last_name:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This code looks fine at the first sight. But the problem lies within the total number of queries executed. The above code executes 1 (to find 10 books) + 10 (one per each book to load the author) = <strong>11</strong> queries in total.</p>

<h4 id="solution-to-n--1-queries-problem">Solution to N + 1 Queries Problem</h4>

<p>Active Record lets you specify in advance all the associations that are going to be loaded.</p>

<p>The methods are:</p>

<ul>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code class="language-plaintext highlighter-rouge">includes</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code class="language-plaintext highlighter-rouge">preload</code></a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code class="language-plaintext highlighter-rouge">eager_load</code></a></li>
</ul>

<h3 id="includes"><code class="language-plaintext highlighter-rouge">includes</code></h3>

<p>With <code class="language-plaintext highlighter-rouge">includes</code>, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.</p>

<p>Revisiting the above case using the <code class="language-plaintext highlighter-rouge">includes</code> method, we could rewrite <code class="language-plaintext highlighter-rouge">Book.limit(10)</code> to eager load authors:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The above code will execute just <strong>2</strong> queries, as opposed to the <strong>11</strong> queries from the original case:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">WHERE</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="eager-loading-multiple-associations">Eager Loading Multiple Associations</h4>

<p>Active Record lets you eager load any number of associations with a single <code class="language-plaintext highlighter-rouge">Model.find</code> call by using an array, hash, or a nested hash of array/hash with the <code class="language-plaintext highlighter-rouge">includes</code> method.</p>

<h5 id="array-of-multiple-associations">Array of Multiple Associations</h5>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:orders</span><span class="p">,</span> <span class="ss">:reviews</span><span class="p">)</span>
</code></pre></div></div>

<p>This loads all the customers and the associated orders and reviews for each.</p>

<h5 id="nested-associations-hash">Nested Associations Hash</h5>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">orders: </span><span class="p">{</span> <span class="ss">books: </span><span class="p">[</span><span class="ss">:supplier</span><span class="p">,</span> <span class="ss">:author</span><span class="p">]</span> <span class="p">}).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>This will find the customer with id 1 and eager load all of the associated orders for it, the books for all of the orders, and the author and supplier for each of the books.</p>

<h4 id="specifying-conditions-on-eager-loaded-associations">Specifying Conditions on Eager Loaded Associations</h4>

<p>Even though Active Record lets you specify conditions on the eager loaded associations just like <code class="language-plaintext highlighter-rouge">joins</code>, the recommended way is to use <a href="#joining-tables">joins</a> instead.</p>

<p>However if you must do this, you may use <code class="language-plaintext highlighter-rouge">where</code> as you would normally.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">books: </span><span class="p">{</span> <span class="ss">out_of_print: </span><span class="kp">true</span> <span class="p">})</span>
</code></pre></div></div>

<p>This would generate a query which contains a <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code> whereas the
<code class="language-plaintext highlighter-rouge">joins</code> method would generate one using the <code class="language-plaintext highlighter-rouge">INNER JOIN</code> function instead.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">t0_r0</span><span class="p">,</span> <span class="p">...</span> <span class="n">books</span><span class="p">.</span><span class="n">updated_at</span> <span class="k">AS</span> <span class="n">t1_r5</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>If there was no <code class="language-plaintext highlighter-rouge">where</code> condition, this would generate the normal set of two queries.</p>

<p>NOTE: Using <code class="language-plaintext highlighter-rouge">where</code> like this will only work when you pass it a Hash. For
SQL-fragments you need to use <code class="language-plaintext highlighter-rouge">references</code> to force joined tables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s2">"books.out_of_print = true"</span><span class="p">).</span><span class="nf">references</span><span class="p">(</span><span class="ss">:books</span><span class="p">)</span>
</code></pre></div></div>

<p>If, in the case of this <code class="language-plaintext highlighter-rouge">includes</code> query, there were no books for any
authors, all the authors would still be loaded. By using <code class="language-plaintext highlighter-rouge">joins</code> (an INNER
JOIN), the join conditions <strong>must</strong> match, otherwise no records will be
returned.</p>

<p>NOTE: If an association is eager loaded as part of a join, any fields from a custom select clause will not be present on the loaded models.
This is because it is ambiguous whether they should appear on the parent record, or the child.</p>

<h3 id="preload"><code class="language-plaintext highlighter-rouge">preload</code></h3>

<p>With <code class="language-plaintext highlighter-rouge">preload</code>, Active Record loads each specified association using one query per association.</p>

<p>Revisiting the N + 1 queries problem, we could rewrite <code class="language-plaintext highlighter-rouge">Book.limit(10)</code> to preload authors:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">preload</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The above code will execute just <strong>2</strong> queries, as opposed to the <strong>11</strong> queries from the original case:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">WHERE</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>NOTE: The <code class="language-plaintext highlighter-rouge">preload</code> method uses an array, hash, or a nested hash of array/hash in the same way as the <code class="language-plaintext highlighter-rouge">includes</code> method to load any number of associations with a single <code class="language-plaintext highlighter-rouge">Model.find</code> call. However, unlike the <code class="language-plaintext highlighter-rouge">includes</code> method, it is not possible to specify conditions for preloaded associations.</p>

<h3 id="eager_load"><code class="language-plaintext highlighter-rouge">eager_load</code></h3>

<p>With <code class="language-plaintext highlighter-rouge">eager_load</code>, Active Record loads all specified associations using a <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code>.</p>

<p>Revisiting the case where N + 1 was occurred using the <code class="language-plaintext highlighter-rouge">eager_load</code> method, we could rewrite <code class="language-plaintext highlighter-rouge">Book.limit(10)</code> to eager load authors:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">eager_load</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The above code will execute just <strong>1</strong> query, as opposed to the <strong>11</strong> queries from the original case:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"books"</span><span class="p">.</span><span class="nv">"id"</span> <span class="k">AS</span> <span class="n">t0_r0</span><span class="p">,</span> <span class="nv">"books"</span><span class="p">.</span><span class="nv">"title"</span> <span class="k">AS</span> <span class="n">t0_r1</span><span class="p">,</span> <span class="p">...</span> <span class="k">FROM</span> <span class="nv">"books"</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="nv">"authors"</span> <span class="k">ON</span> <span class="nv">"authors"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="nv">"books"</span><span class="p">.</span><span class="nv">"author_id"</span>
  <span class="k">LIMIT</span> <span class="mi">10</span>
</code></pre></div></div>

<p>NOTE: The <code class="language-plaintext highlighter-rouge">eager_load</code> method uses an array, hash, or a nested hash of array/hash in the same way as the <code class="language-plaintext highlighter-rouge">includes</code> method to load any number of associations with a single <code class="language-plaintext highlighter-rouge">Model.find</code> call. Also, like the <code class="language-plaintext highlighter-rouge">includes</code> method, you can specify conditions for eager loaded associations.</p>

<h3 id="strict_loading"><code class="language-plaintext highlighter-rouge">strict_loading</code></h3>

<p>Eager loading can prevent N + 1 queries but you might still be lazy loading
some associations. To make sure no associations are lazy loaded you can enable
<a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-strict_loading"><code class="language-plaintext highlighter-rouge">strict_loading</code></a>.</p>

<p>By enabling strict loading mode on a relation, an
<code class="language-plaintext highlighter-rouge">ActiveRecord::StrictLoadingViolationError</code> will be raised if the record tries
to lazily load any association:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">strict_loading</span><span class="p">.</span><span class="nf">first</span>
<span class="n">user</span><span class="p">.</span><span class="nf">address</span><span class="p">.</span><span class="nf">city</span> <span class="c1"># raises an ActiveRecord::StrictLoadingViolationError</span>
<span class="n">user</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_a</span> <span class="c1"># raises an ActiveRecord::StrictLoadingViolationError</span>
</code></pre></div></div>

<p>To enable for all relations, change the
<a href="configuring.html#config-active-record-strict-loading-by-default"><code class="language-plaintext highlighter-rouge">config.active_record.strict_loading_by_default</code></a> flag to <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>To send violations to the logger instead, change
<a href="configuring.html#config-active-record-action-on-strict-loading-violation"><code class="language-plaintext highlighter-rouge">config.active_record.action_on_strict_loading_violation</code></a> to <code class="language-plaintext highlighter-rouge">:log</code>.</p>

<h3 id="strict_loading-1"><code class="language-plaintext highlighter-rouge">strict_loading!</code></h3>

<p>We can also enable strict loading on the record itself by calling <a href="https://api.rubyonrails.org/classes/ActiveRecord/Core.html#method-i-strict_loading-21"><code class="language-plaintext highlighter-rouge">strict_loading!</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">first</span>
<span class="n">user</span><span class="p">.</span><span class="nf">strict_loading!</span>
<span class="n">user</span><span class="p">.</span><span class="nf">address</span><span class="p">.</span><span class="nf">city</span> <span class="c1"># raises an ActiveRecord::StrictLoadingViolationError</span>
<span class="n">user</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_a</span> <span class="c1"># raises an ActiveRecord::StrictLoadingViolationError</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">strict_loading!</code> also takes a <code class="language-plaintext highlighter-rouge">:mode</code> argument. Setting it to <code class="language-plaintext highlighter-rouge">:n_plus_one_only</code>
will only raise an error if an association that will lead to an N + 1 query is
lazily loaded:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="p">.</span><span class="nf">strict_loading!</span><span class="p">(</span><span class="ss">mode: :n_plus_one_only</span><span class="p">)</span>
<span class="n">user</span><span class="p">.</span><span class="nf">address</span><span class="p">.</span><span class="nf">city</span> <span class="c1"># =&gt; "Tatooine"</span>
<span class="n">user</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_a</span> <span class="c1"># =&gt; [#&lt;Comment:0x00...]</span>
<span class="n">user</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">likes</span><span class="p">.</span><span class="nf">to_a</span> <span class="c1"># raises an ActiveRecord::StrictLoadingViolationError</span>
</code></pre></div></div>

<h3 id="strict_loading-option-on-an-association"><code class="language-plaintext highlighter-rouge">strict_loading</code> option on an association</h3>

<p>We can also enable strict loading for a single association by providing the <code class="language-plaintext highlighter-rouge">strict_loading</code> option:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="ss">strict_loading: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="scopes">Scopes</h2>

<p>Scoping allows you to specify commonly-used queries which can be referenced as method calls on the association objects or models. With these scopes, you can use every method previously covered such as <code class="language-plaintext highlighter-rouge">where</code>, <code class="language-plaintext highlighter-rouge">joins</code> and <code class="language-plaintext highlighter-rouge">includes</code>. All scope bodies should return an <code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code> or <code class="language-plaintext highlighter-rouge">nil</code> to allow for further methods (such as other scopes) to be called on it.</p>

<p>To define a simple scope, we use the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Scoping/Named/ClassMethods.html#method-i-scope"><code class="language-plaintext highlighter-rouge">scope</code></a> method inside the class, passing the query that we’d like to run when this scope is called:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>To call this <code class="language-plaintext highlighter-rouge">out_of_print</code> scope we can call it on either the class:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># all out of print books</span>
</code></pre></div></div>

<p>Or on an association consisting of <code class="language-plaintext highlighter-rouge">Book</code> objects:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span> <span class="o">=</span> <span class="no">Author</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">.</span><span class="nf">books</span><span class="p">.</span><span class="nf">out_of_print</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># all out of print books by `author`</span>
</code></pre></div></div>

<p>Scopes are also chainable within scopes:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print_and_expensive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">out_of_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"price &gt; 500"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="passing-in-arguments">Passing in Arguments</h3>

<p>Your scope can take arguments:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:costs_more_than</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"price &gt; ?"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Call the scope as if it were a class method:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="mf">100.10</span><span class="p">)</span>
</code></pre></div></div>

<p>However, this is just duplicating the functionality that would be provided to you by a class method.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"price &gt; ?"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>These methods will still be accessible on the association objects:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">.</span><span class="nf">books</span><span class="p">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="mf">100.10</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="using-conditionals">Using Conditionals</h3>

<p>Your scope can utilize conditionals:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Like the other examples, this will behave similarly to a class method.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">created_before</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>However, there is one important caveat: A scope will always return an <code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code> object, even if the conditional evaluates to <code class="language-plaintext highlighter-rouge">false</code>, whereas a class method, will return <code class="language-plaintext highlighter-rouge">nil</code>. This can cause <code class="language-plaintext highlighter-rouge">NoMethodError</code> when chaining class methods with conditionals, if any of the conditionals return <code class="language-plaintext highlighter-rouge">false</code>.</p>

<h3 id="applying-a-default-scope">Applying a Default Scope</h3>

<p>If we wish for a scope to be applied across all queries to the model we can use the
<a href="https://api.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-default_scope"><code class="language-plaintext highlighter-rouge">default_scope</code></a> method within the model itself.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When queries are executed on this model, the SQL query will now look something like
this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
</code></pre></div></div>

<p>If you need to do more complex things with a default scope, you can alternatively
define it as a class method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default_scope</span>
    <span class="c1"># Should return an ActiveRecord::Relation.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>NOTE: The <code class="language-plaintext highlighter-rouge">default_scope</code> is also applied while creating/building a record
when the scope arguments are given as a <code class="language-plaintext highlighter-rouge">Hash</code>. It is not applied while
updating a record. E.g.:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">false</span><span class="kt">&gt;</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">nil</span><span class="kt">&gt;</span>
</code></pre></div></div>

<p>Be aware that, when given in the <code class="language-plaintext highlighter-rouge">Array</code> format, <code class="language-plaintext highlighter-rouge">default_scope</code> query arguments
cannot be converted to a <code class="language-plaintext highlighter-rouge">Hash</code> for default attribute assignment. E.g.:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"out_of_print = ?"</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">nil</span><span class="kt">&gt;</span>
</code></pre></div></div>

<h3 id="merging-of-scopes">Merging of Scopes</h3>

<p>Just like <code class="language-plaintext highlighter-rouge">where</code> clauses, scopes are merged using <code class="language-plaintext highlighter-rouge">AND</code> conditions.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">scope</span> <span class="ss">:recent</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="o">..</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:old</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="o">...</span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span><span class="p">.</span><span class="nf">old</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = 'true' AND books.year_published &lt; 1969
</span></code></pre></div></div>

<p>We can mix and match <code class="language-plaintext highlighter-rouge">scope</code> and <code class="language-plaintext highlighter-rouge">where</code> conditions and the final SQL
will have all conditions joined with <code class="language-plaintext highlighter-rouge">AND</code>.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">price: </span><span class="o">...</span><span class="mi">100</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = 'false' AND books.price &lt; 100
</span></code></pre></div></div>

<p>If we do want the last <code class="language-plaintext highlighter-rouge">where</code> clause to win then <a href="https://api.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code class="language-plaintext highlighter-rouge">merge</code></a> can
be used.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = true
</span></code></pre></div></div>

<p>One important caveat is that <code class="language-plaintext highlighter-rouge">default_scope</code> will be prepended in
<code class="language-plaintext highlighter-rouge">scope</code> and <code class="language-plaintext highlighter-rouge">where</code> conditions.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="o">..</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969)
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND books.out_of_print = false
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'price &gt; 50'</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND (price &gt; 50)
</span></code></pre></div></div>

<p>As you can see above the <code class="language-plaintext highlighter-rouge">default_scope</code> is being merged in both
<code class="language-plaintext highlighter-rouge">scope</code> and <code class="language-plaintext highlighter-rouge">where</code> conditions.</p>

<h3 id="removing-all-scoping">Removing All Scoping</h3>

<p>If we wish to remove scoping for any reason we can use the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-unscoped"><code class="language-plaintext highlighter-rouge">unscoped</code></a> method. This is
especially useful if a <code class="language-plaintext highlighter-rouge">default_scope</code> is specified in the model and should not be
applied for this particular query.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">load</span>
</code></pre></div></div>

<p>This method removes all scoping and will do a normal query on the table.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">unscoped</code> can also accept a block:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span> <span class="p">{</span> <span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span> <span class="p">}</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = true
</span></code></pre></div></div>

<h2 id="dynamic-finders">Dynamic Finders</h2>

<p>For every field (also known as an attribute) you define in your table,
Active Record provides a finder method. If you have a field called <code class="language-plaintext highlighter-rouge">first_name</code> on your <code class="language-plaintext highlighter-rouge">Customer</code> model for example,
you get the instance method <code class="language-plaintext highlighter-rouge">find_by_first_name</code> for free from Active Record.
If you also have a <code class="language-plaintext highlighter-rouge">locked</code> field on the <code class="language-plaintext highlighter-rouge">Customer</code> model, you also get <code class="language-plaintext highlighter-rouge">find_by_locked</code> method.</p>

<p>You can specify an exclamation point (<code class="language-plaintext highlighter-rouge">!</code>) on the end of the dynamic finders
to get them to raise an <code class="language-plaintext highlighter-rouge">ActiveRecord::RecordNotFound</code> error if they do not return any records, like <code class="language-plaintext highlighter-rouge">Customer.find_by_first_name!("Ryan")</code></p>

<p>If you want to find both by <code class="language-plaintext highlighter-rouge">first_name</code> and <code class="language-plaintext highlighter-rouge">orders_count</code>, you can chain these finders together by simply typing “<code class="language-plaintext highlighter-rouge">and</code>” between the fields.
For example, <code class="language-plaintext highlighter-rouge">Customer.find_by_first_name_and_orders_count("Ryan", 5)</code>.</p>

<h2 id="enums">Enums</h2>

<p>An enum lets you define an Array of values for an attribute and refer to them by name.  The actual value stored in the database is an integer that has been mapped to one of the values.</p>

<p>Declaring an enum will:</p>

<ul>
  <li>Create scopes that can be used to find all objects that have or do not have one of the enum values</li>
  <li>Create an instance method that can be used to determine if an object has a particular value for the enum</li>
  <li>Create an instance method that can be used to change the enum value of an object</li>
</ul>

<p>for all possible values of an enum.</p>

<p>For example, given this <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html#method-i-enum"><code class="language-plaintext highlighter-rouge">enum</code></a> declaration:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">enum</span> <span class="ss">:status</span><span class="p">,</span> <span class="p">[</span><span class="ss">:shipped</span><span class="p">,</span> <span class="ss">:being_packaged</span><span class="p">,</span> <span class="ss">:complete</span><span class="p">,</span> <span class="ss">:cancelled</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>These <a href="#scopes">scopes</a> are created automatically and can be used to find all objects with or without a particular value for <code class="language-plaintext highlighter-rouge">status</code>:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># all orders with status == :shipped</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">not_shipped</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># all orders with status != :shipped</span>
</code></pre></div></div>

<p>These instance methods are created automatically and query whether the model has that value for the <code class="language-plaintext highlighter-rouge">status</code> enum:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">shipped?</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">complete?</span>
<span class="p">=&gt;</span> <span class="kp">false</span>
</code></pre></div></div>

<p>These instance methods are created automatically and will first update the value of <code class="language-plaintext highlighter-rouge">status</code> to the named value
and then query whether or not the status has been successfully set to the value:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">shipped!</span>
<span class="go">UPDATE "orders" SET "status" = ?, "updated_at" = ? WHERE "orders"."id" = ?  [["status", 0], ["updated_at", "2019-01-24 07:13:08.524320"], ["id", 1]]
</span><span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div>

<p>Full documentation about enums can be found <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html">here</a>.</p>

<h2 id="understanding-method-chaining">Understanding Method Chaining</h2>

<p>The Active Record pattern implements <a href="https://en.wikipedia.org/wiki/Method_chaining">Method Chaining</a>,
which allows us to use multiple Active Record methods together in a simple and straightforward way.</p>

<p>You can chain methods in a statement when the previous method called returns an
<a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html"><code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code></a>, like <code class="language-plaintext highlighter-rouge">all</code>, <code class="language-plaintext highlighter-rouge">where</code>, and <code class="language-plaintext highlighter-rouge">joins</code>. Methods that return
a single object (see <a href="#retrieving-a-single-object">Retrieving a Single Object Section</a>)
have to be at the end of the statement.</p>

<p>There are some examples below. This guide won’t cover all the possibilities, just a few as examples.
When an Active Record method is called, the query is not immediately generated and sent to the database.
The query is sent only when the data is actually needed. So each example below generates a single query.</p>

<h3 id="retrieving-filtered-data-from-multiple-tables">Retrieving Filtered Data from Multiple Tables</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"customers.id, customers.last_name, reviews.body"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"reviews.created_at &gt; ?"</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
</code></pre></div></div>

<p>The result should be something like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">reviews</span><span class="p">.</span><span class="n">body</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span>
  <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">reviews</span><span class="p">.</span><span class="n">created_at</span> <span class="o">&gt;</span> <span class="s1">'2019-01-08'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="retrieving-specific-data-from-multiple-tables">Retrieving Specific Data from Multiple Tables</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"books.id, books.title, authors.first_name"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:author</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Abstraction and Specification in Program Development"</span><span class="p">)</span>
</code></pre></div></div>

<p>The above should generate:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">authors</span><span class="p">.</span><span class="n">first_name</span>
<span class="k">FROM</span> <span class="n">books</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">authors</span>
  <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="p">[[</span><span class="nv">"title"</span><span class="p">,</span> <span class="nv">"Abstraction and Specification in Program Development"</span><span class="p">]]</span>
<span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>NOTE: Note that if a query matches multiple records, <code class="language-plaintext highlighter-rouge">find_by</code> will
fetch only the first one and ignore the others (see the <code class="language-plaintext highlighter-rouge">LIMIT 1</code>
statement above).</p>

<h2 id="find-or-build-a-new-object">Find or Build a New Object</h2>

<p>It’s common that you need to find a record or create it if it doesn’t exist. You can do that with the <code class="language-plaintext highlighter-rouge">find_or_create_by</code> and <code class="language-plaintext highlighter-rouge">find_or_create_by!</code> methods.</p>

<h3 id="find_or_create_by"><code class="language-plaintext highlighter-rouge">find_or_create_by</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by"><code class="language-plaintext highlighter-rouge">find_or_create_by</code></a> method checks whether a record with the specified attributes exists. If it doesn’t, then <code class="language-plaintext highlighter-rouge">create</code> is called. Let’s see an example.</p>

<p>Suppose you want to find a customer named “Andy”, and if there’s none, create one. You can do so by running:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="gp">=&gt; #&lt;Customer id: 5, first_name: "Andy", last_name: nil, title: nil, visits: 0, orders_count: nil, lock_version: 0, created_at: "2019-01-17 07:06:45", updated_at: "2019-01-17 07:06:45"&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The SQL generated by this method looks like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Andy'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">customers</span> <span class="p">(</span><span class="n">created_at</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">locked</span><span class="p">,</span> <span class="n">orders_count</span><span class="p">,</span> <span class="n">updated_at</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'2011-08-30 05:22:57'</span><span class="p">,</span> <span class="s1">'Andy'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="s1">'2011-08-30 05:22:57'</span><span class="p">)</span>
<span class="k">COMMIT</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">find_or_create_by</code> returns either the record that already exists or the new record. In our case, we didn’t already have a customer named Andy so the record is created and returned.</p>

<p>The new record might not be saved to the database; that depends on whether validations passed or not (just like <code class="language-plaintext highlighter-rouge">create</code>).</p>

<p>Suppose we want to set the ‘locked’ attribute to <code class="language-plaintext highlighter-rouge">false</code> if we’re
creating a new record, but we don’t want to include it in the query. So
we want to find the customer named “Andy”, or if that customer doesn’t
exist, create a customer named “Andy” which is not locked.</p>

<p>We can achieve this in two ways. The first is to use <code class="language-plaintext highlighter-rouge">create_with</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">create_with</span><span class="p">(</span><span class="ss">locked: </span><span class="kp">false</span><span class="p">).</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s2">"Andy"</span><span class="p">)</span>
</code></pre></div></div>

<p>The second way is using a block:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s2">"Andy"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
  <span class="n">c</span><span class="p">.</span><span class="nf">locked</span> <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The block will only be executed if the customer is being created. The
second time we run this code, the block will be ignored.</p>

<h3 id="find_or_create_by-1"><code class="language-plaintext highlighter-rouge">find_or_create_by!</code></h3>

<p>You can also use <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by-21"><code class="language-plaintext highlighter-rouge">find_or_create_by!</code></a> to raise an exception if the new record is invalid. Validations are not covered on this guide, but let’s assume for a moment that you temporarily add</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">validates</span> <span class="ss">:orders_count</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
</code></pre></div></div>

<p>to your <code class="language-plaintext highlighter-rouge">Customer</code> model. If you try to create a new <code class="language-plaintext highlighter-rouge">Customer</code> without passing an <code class="language-plaintext highlighter-rouge">orders_count</code>, the record will be invalid and an exception will be raised:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="go">ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
</span></code></pre></div></div>

<h3 id="find_or_initialize_by"><code class="language-plaintext highlighter-rouge">find_or_initialize_by</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_initialize_by"><code class="language-plaintext highlighter-rouge">find_or_initialize_by</code></a> method will work just like
<code class="language-plaintext highlighter-rouge">find_or_create_by</code> but it will call <code class="language-plaintext highlighter-rouge">new</code> instead of <code class="language-plaintext highlighter-rouge">create</code>. This
means that a new model instance will be created in memory but won’t be
saved to the database. Continuing with the <code class="language-plaintext highlighter-rouge">find_or_create_by</code> example, we
now want the customer named ‘Nina’:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_initialize_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Nina'</span><span class="p">)</span>
<span class="gp">=&gt; #&lt;Customer id: nil, first_name: "Nina", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;</span><span class="w">
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">persisted?</span>
<span class="p">=&gt;</span> <span class="kp">false</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">new_record?</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div>

<p>Because the object is not yet stored in the database, the SQL generated looks like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Nina'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>When you want to save it to the database, just call <code class="language-plaintext highlighter-rouge">save</code>:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">save</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div>

<h2 id="finding-by-sql">Finding by SQL</h2>

<p>If you’d like to use your own SQL to find records in a table you can use <a href="https://api.rubyonrails.org/classes/ActiveRecord/Querying.html#method-i-find_by_sql"><code class="language-plaintext highlighter-rouge">find_by_sql</code></a>. The <code class="language-plaintext highlighter-rouge">find_by_sql</code> method will return an array of objects even if the underlying query returns just a single record. For example, you could run this query:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by_sql</span><span class="p">(</span><span class="s2">"SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc"</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lucas"</span> <span class="o">...</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Jan"</span> <span class="o">...</span><span class="kt">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">find_by_sql</code> provides you with a simple way of making custom calls to the database and retrieving instantiated objects.</p>

<h3 id="select_all"><code class="language-plaintext highlighter-rouge">select_all</code></h3>

<p><code class="language-plaintext highlighter-rouge">find_by_sql</code> has a close relative called <a href="https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_all"><code class="language-plaintext highlighter-rouge">lease_connection.select_all</code></a>. <code class="language-plaintext highlighter-rouge">select_all</code> will retrieve
objects from the database using custom SQL just like <code class="language-plaintext highlighter-rouge">find_by_sql</code> but will not instantiate them.
This method will return an instance of <code class="language-plaintext highlighter-rouge">ActiveRecord::Result</code> class and calling <code class="language-plaintext highlighter-rouge">to_a</code> on this
object would return you an array of hashes where each hash indicates a record.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">lease_connection</span><span class="p">.</span><span class="nf">select_all</span><span class="p">(</span><span class="s2">"SELECT first_name, created_at FROM customers WHERE id = '1'"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="p">=&gt;</span> <span class="p">[{</span><span class="s2">"first_name"</span><span class="o">=&gt;</span><span class="s2">"Rafael"</span><span class="p">,</span> <span class="s2">"created_at"</span><span class="o">=&gt;</span><span class="s2">"2012-11-10 23:23:45.281189"</span><span class="p">},</span> <span class="p">{</span><span class="s2">"first_name"</span><span class="o">=&gt;</span><span class="s2">"Eileen"</span><span class="p">,</span> <span class="s2">"created_at"</span><span class="o">=&gt;</span><span class="s2">"2013-12-09 11:22:35.221282"</span><span class="p">}]</span>
</code></pre></div></div>

<h3 id="pluck"><code class="language-plaintext highlighter-rouge">pluck</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pluck"><code class="language-plaintext highlighter-rouge">pluck</code></a> can be used to pick the value(s) from the named column(s) in the current relation. It accepts a list of column names as an argument and returns an array of values of the specified columns with the corresponding data type.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="go">SELECT id FROM books WHERE out_of_print = true
</span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:status</span><span class="p">)</span>
<span class="go">SELECT DISTINCT status FROM orders
</span><span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"shipped"</span><span class="p">,</span> <span class="s2">"being_packed"</span><span class="p">,</span> <span class="s2">"cancelled"</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">)</span>
<span class="go">SELECT customers.id, customers.first_name FROM customers
</span><span class="p">=&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"David"</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"Fran"</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s2">"Jose"</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">pluck</code> makes it possible to replace code like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">c</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
<span class="c1"># or</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># or</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="nf">first_name</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<p>with:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># or</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">)</span>
</code></pre></div></div>

<p>Unlike <code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">pluck</code> directly converts a database result into a Ruby <code class="language-plaintext highlighter-rouge">Array</code>,
without constructing <code class="language-plaintext highlighter-rouge">ActiveRecord</code> objects. This can mean better performance for
a large or frequently-run query. However, any model method overrides will
not be available. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nf">name</span>
    <span class="s2">"I am </span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">map</span> <span class="o">&amp;</span><span class="ss">:name</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"I am David"</span><span class="p">,</span> <span class="s2">"I am Jeremy"</span><span class="p">,</span> <span class="s2">"I am Jose"</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"David"</span><span class="p">,</span> <span class="s2">"Jeremy"</span><span class="p">,</span> <span class="s2">"Jose"</span><span class="p">]</span>
</code></pre></div></div>

<p>You are not limited to querying fields from a single table, you can query multiple tables as well.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:customer</span><span class="p">,</span> <span class="ss">:books</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="s2">"orders.created_at, customers.email, books.title"</span><span class="p">)</span>
</code></pre></div></div>

<p>Furthermore, unlike <code class="language-plaintext highlighter-rouge">select</code> and other <code class="language-plaintext highlighter-rouge">Relation</code> scopes, <code class="language-plaintext highlighter-rouge">pluck</code> triggers an immediate
query, and thus cannot be chained with any further scopes, although it can work with
scopes already constructed earlier:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"David"</span><span class="p">]</span>
</code></pre></div></div>

<p>NOTE: You should also know that using <code class="language-plaintext highlighter-rouge">pluck</code> will trigger eager loading if the relation object contains include values, even if the eager loading is not necessary for the query. For example:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="go">SELECT "customers"."id" FROM "customers" LEFT OUTER JOIN "reviews" ON "reviews"."id" = "customers"."review_id"
</span></code></pre></div></div>

<p>One way to avoid this is to <code class="language-plaintext highlighter-rouge">unscope</code> the includes:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span><span class="p">.</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:includes</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="pick"><code class="language-plaintext highlighter-rouge">pick</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pick"><code class="language-plaintext highlighter-rouge">pick</code></a> can be used to pick the value(s) from the named column(s) in the current relation. It accepts a list of column names as an argument and returns the first row of the specified column values ​​with corresponding data type.
<code class="language-plaintext highlighter-rouge">pick</code> is a short-hand for <code class="language-plaintext highlighter-rouge">relation.limit(1).pluck(*column_names).first</code>, which is primarily useful when you already have a relation that is limited to one row.</p>

<p><code class="language-plaintext highlighter-rouge">pick</code> makes it possible to replace code like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">first</span>
</code></pre></div></div>

<p>with:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">pick</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="ids"><code class="language-plaintext highlighter-rouge">ids</code></h3>

<p><a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-ids"><code class="language-plaintext highlighter-rouge">ids</code></a> can be used to pluck all the IDs for the relation using the table’s primary key.</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">ids</span>
<span class="go">SELECT id FROM customers
</span></code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"customer_id"</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">ids</span>
<span class="go">SELECT customer_id FROM customers
</span></code></pre></div></div>

<h2 id="existence-of-objects">Existence of Objects</h2>

<p>If you simply want to check for the existence of the object there’s a method called <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F"><code class="language-plaintext highlighter-rouge">exists?</code></a>.
This method will query the database using the same query as <code class="language-plaintext highlighter-rouge">find</code>, but instead of returning an
object or collection of objects it will return either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">exists?</code> method also takes multiple values, but the catch is that it will return <code class="language-plaintext highlighter-rouge">true</code> if any
one of those records exists.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1"># or</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">first_name: </span><span class="p">[</span><span class="s2">"Jane"</span><span class="p">,</span> <span class="s2">"Sergei"</span><span class="p">])</span>
</code></pre></div></div>

<p>It’s even possible to use <code class="language-plaintext highlighter-rouge">exists?</code> without any arguments on a model or a relation.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s2">"Ryan"</span><span class="p">).</span><span class="nf">exists?</span>
</code></pre></div></div>

<p>The above returns <code class="language-plaintext highlighter-rouge">true</code> if there is at least one customer with the <code class="language-plaintext highlighter-rouge">first_name</code> ‘Ryan’ and <code class="language-plaintext highlighter-rouge">false</code>
otherwise.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span>
</code></pre></div></div>

<p>The above returns <code class="language-plaintext highlighter-rouge">false</code> if the <code class="language-plaintext highlighter-rouge">customers</code> table is empty and <code class="language-plaintext highlighter-rouge">true</code> otherwise.</p>

<p>You can also use <code class="language-plaintext highlighter-rouge">any?</code> and <code class="language-plaintext highlighter-rouge">many?</code> to check for existence on a model or relation.  <code class="language-plaintext highlighter-rouge">many?</code> will use SQL <code class="language-plaintext highlighter-rouge">count</code> to determine if the item exists.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># via a model</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">any?</span>
<span class="c1"># SELECT 1 FROM orders LIMIT 1</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">many?</span>
<span class="c1"># SELECT COUNT(*) FROM (SELECT 1 FROM orders LIMIT 2)</span>

<span class="c1"># via a named scope</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">any?</span>
<span class="c1"># SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 1</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">many?</span>
<span class="c1"># SELECT COUNT(*) FROM (SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 2)</span>

<span class="c1"># via a relation</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">any?</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">many?</span>

<span class="c1"># via an association</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">any?</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">many?</span>
</code></pre></div></div>

<h2 id="calculations">Calculations</h2>

<p>This section uses <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-count"><code class="language-plaintext highlighter-rouge">count</code></a> as an example method in this preamble, but the options described apply to all sub-sections.</p>

<p>All calculation methods work directly on a model:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">count</span>
<span class="go">SELECT COUNT(*) FROM customers
</span></code></pre></div></div>

<p>Or on a relation:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">).</span><span class="nf">count</span>
<span class="go">SELECT COUNT(*) FROM customers WHERE (first_name = 'Ryan')
</span></code></pre></div></div>

<p>You can also use various finder methods on a relation for performing complex calculations:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="s2">"orders"</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">,</span> <span class="ss">orders: </span><span class="p">{</span> <span class="ss">status: </span><span class="s1">'shipped'</span> <span class="p">}).</span><span class="nf">count</span>
</code></pre></div></div>

<p>Which will execute:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span> <span class="k">AND</span> <span class="n">orders</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>assuming that Order has <code class="language-plaintext highlighter-rouge">enum status: [ :shipped, :being_packed, :cancelled ]</code>.</p>

<h3 id="count"><code class="language-plaintext highlighter-rouge">count</code></h3>

<p>If you want to see how many records are in your model’s table you could call <code class="language-plaintext highlighter-rouge">Customer.count</code> and that will return the number.
If you want to be more specific and find all the customers with a title present in the database you can use <code class="language-plaintext highlighter-rouge">Customer.count(:title)</code>.</p>

<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>

<h3 id="average"><code class="language-plaintext highlighter-rouge">average</code></h3>

<p>If you want to see the average of a certain number in one of your tables you can call the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-average"><code class="language-plaintext highlighter-rouge">average</code></a> method on the class that relates to the table. This method call will look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Order</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre></div></div>

<p>This will return a number (possibly a floating-point number such as 3.14159265) representing the average value in the field.</p>

<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>

<h3 id="minimum"><code class="language-plaintext highlighter-rouge">minimum</code></h3>

<p>If you want to find the minimum value of a field in your table you can call the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-minimum"><code class="language-plaintext highlighter-rouge">minimum</code></a> method on the class that relates to the table. This method call will look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Order</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre></div></div>

<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>

<h3 id="maximum"><code class="language-plaintext highlighter-rouge">maximum</code></h3>

<p>If you want to find the maximum value of a field in your table you can call the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-maximum"><code class="language-plaintext highlighter-rouge">maximum</code></a> method on the class that relates to the table. This method call will look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Order</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre></div></div>

<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>

<h3 id="sum"><code class="language-plaintext highlighter-rouge">sum</code></h3>

<p>If you want to find the sum of a field for all records in your table you can call the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-sum"><code class="language-plaintext highlighter-rouge">sum</code></a> method on the class that relates to the table. This method call will look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Order</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre></div></div>

<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>

<h2 id="running-explain">Running EXPLAIN</h2>

<p>You can run <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-explain"><code class="language-plaintext highlighter-rouge">explain</code></a> on a relation. EXPLAIN output varies for each database.</p>

<p>For example, running:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span>
</code></pre></div></div>

<p>may yield this for MySQL and MariaDB:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="nv">`customers`</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">`customers`</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">`orders`</span> <span class="k">ON</span> <span class="nv">`orders`</span><span class="p">.</span><span class="nv">`customer_id`</span> <span class="o">=</span> <span class="nv">`customers`</span><span class="p">.</span><span class="nv">`id`</span> <span class="k">WHERE</span> <span class="nv">`customers`</span><span class="p">.</span><span class="nv">`id`</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">+</span><span class="c1">----+-------------+------------+-------+---------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>      <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+------------+-------+---------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">customers</span>  <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">orders</span>     <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+------------+-------+---------------+</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------------+</span>
<span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------------+</span>
<span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>             <span class="o">|</span>
<span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------------+</span>

<span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<p>Active Record performs pretty printing that emulates the output of
the corresponding database shell. So, the same query run with the
PostgreSQL adapter would instead yield:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="nv">"customers"</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">"customers"</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">"orders"</span> <span class="k">ON</span> <span class="nv">"orders"</span><span class="p">.</span><span class="nv">"customer_id"</span> <span class="o">=</span> <span class="nv">"customers"</span><span class="p">.</span><span class="nv">"id"</span> <span class="k">WHERE</span> <span class="nv">"customers"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="p">[[</span><span class="nv">"id"</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                                  <span class="n">QUERY</span> <span class="n">PLAN</span>
<span class="c1">------------------------------------------------------------------------------</span>
 <span class="n">Nested</span> <span class="n">Loop</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">4</span><span class="p">.</span><span class="mi">33</span><span class="p">..</span><span class="mi">20</span><span class="p">.</span><span class="mi">85</span> <span class="k">rows</span><span class="o">=</span><span class="mi">4</span> <span class="n">width</span><span class="o">=</span><span class="mi">164</span><span class="p">)</span>
    <span class="o">-&gt;</span>  <span class="k">Index</span> <span class="n">Scan</span> <span class="k">using</span> <span class="n">customers_pkey</span> <span class="k">on</span> <span class="n">customers</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">15</span><span class="p">..</span><span class="mi">8</span><span class="p">.</span><span class="mi">17</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">164</span><span class="p">)</span>
          <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">::</span><span class="nb">bigint</span><span class="p">)</span>
    <span class="o">-&gt;</span>  <span class="n">Bitmap</span> <span class="n">Heap</span> <span class="n">Scan</span> <span class="k">on</span> <span class="n">orders</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">4</span><span class="p">.</span><span class="mi">18</span><span class="p">..</span><span class="mi">12</span><span class="p">.</span><span class="mi">64</span> <span class="k">rows</span><span class="o">=</span><span class="mi">4</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
          <span class="k">Recheck</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">customer_id</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">::</span><span class="nb">bigint</span><span class="p">)</span>
          <span class="o">-&gt;</span>  <span class="n">Bitmap</span> <span class="k">Index</span> <span class="n">Scan</span> <span class="k">on</span> <span class="n">index_orders_on_customer_id</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">4</span><span class="p">.</span><span class="mi">18</span> <span class="k">rows</span><span class="o">=</span><span class="mi">4</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">customer_id</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">::</span><span class="nb">bigint</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span> <span class="k">rows</span><span class="p">)</span>
</code></pre></div></div>

<p>Eager loading may trigger more than one query under the hood, and some queries
may need the results of previous ones. Because of that, <code class="language-plaintext highlighter-rouge">explain</code> actually
executes the query, and then asks for the query plans. For example, running:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span>
</code></pre></div></div>

<p>may yield this for MySQL and MariaDB:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="nv">`customers`</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">`customers`</span>  <span class="k">WHERE</span> <span class="nv">`customers`</span><span class="p">.</span><span class="nv">`id`</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">+</span><span class="c1">----+-------------+-----------+-------+---------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>     <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-----------+-------+---------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">customers</span> <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-----------+-------+---------------+</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------+</span>
<span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">Extra</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------+</span>
<span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------+</span>

<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="nv">`orders`</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">`orders`</span>  <span class="k">WHERE</span> <span class="nv">`orders`</span><span class="p">.</span><span class="nv">`customer_id`</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">+</span><span class="c1">----+-------------+--------+------+---------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>  <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+--------+------+---------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">orders</span> <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+--------+------+---------------+</span>
<span class="o">+</span><span class="c1">------+---------+------+------+-------------+</span>
<span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">------+---------+------+------+-------------+</span>
<span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">------+---------+------+------+-------------+</span>


<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<p>and may yield this for PostgreSQL:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Customer</span> <span class="k">Load</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">ms</span><span class="p">)</span>  <span class="k">SELECT</span> <span class="nv">"customers"</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">"customers"</span> <span class="k">WHERE</span> <span class="nv">"customers"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span>  <span class="p">[[</span><span class="nv">"id"</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
  <span class="k">Order</span> <span class="k">Load</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">ms</span><span class="p">)</span>  <span class="k">SELECT</span> <span class="nv">"orders"</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">"orders"</span> <span class="k">WHERE</span> <span class="nv">"orders"</span><span class="p">.</span><span class="nv">"customer_id"</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span>  <span class="p">[[</span><span class="nv">"customer_id"</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="o">=&gt;</span> <span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="nv">"customers"</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">"customers"</span> <span class="k">WHERE</span> <span class="nv">"customers"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="p">[[</span><span class="nv">"id"</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                                    <span class="n">QUERY</span> <span class="n">PLAN</span>
<span class="c1">----------------------------------------------------------------------------------</span>
 <span class="k">Index</span> <span class="n">Scan</span> <span class="k">using</span> <span class="n">customers_pkey</span> <span class="k">on</span> <span class="n">customers</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">15</span><span class="p">..</span><span class="mi">8</span><span class="p">.</span><span class="mi">17</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">164</span><span class="p">)</span>
   <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">::</span><span class="nb">bigint</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span> <span class="k">rows</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="explain-options">Explain Options</h3>

<p>For databases and adapters which support them (currently PostgreSQL, MySQL, and MariaDB), options can be passed to provide deeper analysis.</p>

<p>Using PostgreSQL, the following:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span><span class="p">(</span><span class="ss">:analyze</span><span class="p">,</span> <span class="ss">:verbose</span><span class="p">)</span>
</code></pre></div></div>

<p>yields:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="p">(</span><span class="k">ANALYZE</span><span class="p">,</span> <span class="k">VERBOSE</span><span class="p">)</span> <span class="k">SELECT</span> <span class="nv">"shop_accounts"</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">"shop_accounts"</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">"customers"</span> <span class="k">ON</span> <span class="nv">"customers"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="nv">"shop_accounts"</span><span class="p">.</span><span class="nv">"customer_id"</span> <span class="k">WHERE</span> <span class="nv">"shop_accounts"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="p">[[</span><span class="nv">"id"</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                                                                   <span class="n">QUERY</span> <span class="n">PLAN</span>
<span class="c1">------------------------------------------------------------------------------------------------------------------------------------------------</span>
 <span class="n">Nested</span> <span class="n">Loop</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">30</span><span class="p">..</span><span class="mi">16</span><span class="p">.</span><span class="mi">37</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span> <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">003</span><span class="p">..</span><span class="mi">0</span><span class="p">.</span><span class="mi">004</span> <span class="k">rows</span><span class="o">=</span><span class="mi">0</span> <span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">Output</span><span class="p">:</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_carrier_id</span>
   <span class="k">Inner</span> <span class="k">Unique</span><span class="p">:</span> <span class="k">true</span>
   <span class="o">-&gt;</span>  <span class="k">Index</span> <span class="n">Scan</span> <span class="k">using</span> <span class="n">shop_accounts_pkey</span> <span class="k">on</span> <span class="k">public</span><span class="p">.</span><span class="n">shop_accounts</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">15</span><span class="p">..</span><span class="mi">8</span><span class="p">.</span><span class="mi">17</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span> <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">003</span><span class="p">..</span><span class="mi">0</span><span class="p">.</span><span class="mi">003</span> <span class="k">rows</span><span class="o">=</span><span class="mi">0</span> <span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
         <span class="k">Output</span><span class="p">:</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_carrier_id</span>
         <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">shop_accounts</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">::</span><span class="nb">bigint</span><span class="p">)</span>
   <span class="o">-&gt;</span>  <span class="k">Index</span> <span class="k">Only</span> <span class="n">Scan</span> <span class="k">using</span> <span class="n">customers_pkey</span> <span class="k">on</span> <span class="k">public</span><span class="p">.</span><span class="n">customers</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">15</span><span class="p">..</span><span class="mi">8</span><span class="p">.</span><span class="mi">17</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="n">never</span> <span class="n">executed</span><span class="p">)</span>
         <span class="k">Output</span><span class="p">:</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
         <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">)</span>
         <span class="n">Heap</span> <span class="n">Fetches</span><span class="p">:</span> <span class="mi">0</span>
 <span class="n">Planning</span> <span class="nb">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">063</span> <span class="n">ms</span>
 <span class="n">Execution</span> <span class="nb">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">011</span> <span class="n">ms</span>
<span class="p">(</span><span class="mi">12</span> <span class="k">rows</span><span class="p">)</span>
</code></pre></div></div>

<p>Using MySQL or MariaDB, the following:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span><span class="p">(</span><span class="ss">:analyze</span><span class="p">)</span>
</code></pre></div></div>

<p>yields:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ANALYZE</span> <span class="k">SELECT</span> <span class="nv">`shop_accounts`</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">`shop_accounts`</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">`customers`</span> <span class="k">ON</span> <span class="nv">`customers`</span><span class="p">.</span><span class="nv">`id`</span> <span class="o">=</span> <span class="nv">`shop_accounts`</span><span class="p">.</span><span class="nv">`customer_id`</span> <span class="k">WHERE</span> <span class="nv">`shop_accounts`</span><span class="p">.</span><span class="nv">`id`</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">r_rows</span> <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">r_filtered</span> <span class="o">|</span> <span class="n">Extra</span>                          <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>   <span class="o">|</span> <span class="k">NULL</span>     <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">no</span> <span class="n">matching</span> <span class="k">row</span> <span class="k">in</span> <span class="n">const</span> <span class="k">table</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<p>NOTE: EXPLAIN and ANALYZE options vary across MySQL and MariaDB versions.
(<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html">MySQL 5.7</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">MySQL 8.0</a>, <a href="https://mariadb.com/kb/en/analyze-and-explain-statements/">MariaDB</a>)</p>

<h3 id="interpreting-explain">Interpreting EXPLAIN</h3>

<p>Interpretation of the output of EXPLAIN is beyond the scope of this guide. The
following pointers may be helpful:</p>

<ul>
  <li>
    <p>SQLite3: <a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p>
  </li>
  <li>
    <p>MySQL: <a href="https://dev.mysql.com/doc/refman/en/explain-output.html">EXPLAIN Output Format</a></p>
  </li>
  <li>
    <p>MariaDB: <a href="https://mariadb.com/kb/en/mariadb/explain/">EXPLAIN</a></p>
  </li>
  <li>
    <p>PostgreSQL: <a href="https://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p>
  </li>
</ul>

        </div>

        <footer class="guide-footer">
            <div class="feedback">
                <h3>Geri Bildirim</h3>
                <p>Bu kılavuzun kalitesini artırmamıza yardımcı olmak için geri bildirimlerinizi bekliyoruz.</p>
                <p>Lütfen <a href="https://github.com/dilankaya127/rails-tr-TR">GitHub Issues</a> üzerinden katkıda bulunun.</p>
            </div>
        </footer>
    </article>
</div>

<script>
// İçindekiler tablosunu otomatik oluştur
document.addEventListener('DOMContentLoaded', function() {
    const toc = document.getElementById('toc');
    const headings = document.querySelectorAll('.guide-content h2, .guide-content h3, .guide-content h4');
    
    if (headings.length > 0) {
        const tocList = document.createElement('ul');
        
        headings.forEach(function(heading, index) {
            const id = 'heading-' + index;
            heading.id = id;
            
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#' + id;
            a.textContent = heading.textContent;
            a.className = 'toc-' + heading.tagName.toLowerCase();
            
            li.appendChild(a);
            tocList.appendChild(li);
        });
        
        toc.appendChild(tocList);
    }
});
</script>
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Rails Kılavuzları Türkçe Çevirisi. Gönüllüler tarafından hazırlanmıştır.</p>
            <p>Orijinal dokümantasyon <a href="https://guides.rubyonrails.org">Ruby on Rails</a> ekibine aittir.</p>
        </div>
    </footer>

    <script>hljs.highlightAll();</script>
</body>
</html>